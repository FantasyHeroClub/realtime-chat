{"version":3,"sources":["../src/XAxisLabels.js"],"names":["resolveXLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","testLabels","map","getLabel","value","format","areLabelsDistinct","push","labelXRanges","label","textAnchor","collisionCount","isUndefined","distinctAttempts","filter","attempt","length","last","minBy","XAxisLabels","nextProps","nextState","props","height","xScale","position","distance","labelStyle","labelClassName","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","spacingTop","spacingBottom","getLabels","placement","className","transform","i","x","y","callback","get","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","dy","text","defaults","defaultProps","xTickDomain","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginY","max","Math","ceil","capitalize","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","getDefaultFormats","Component","propTypes","func","undefined","nice","fontFamily","fontSize","lineHeight","XAxisLabelDebugRect","width","fill"],"mappings":"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","file":"XAxisLabels.js","sourcesContent":["import React from 'react';\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\n\nimport MeasuredValueLabel from './MeasuredValueLabel';\nimport {getScaleTicks, inferScaleType, getTickDomain} from './utils/Scale';\nimport {checkLabelsDistinct, countRangeOverlaps, makeLabelFormatters, getLabelXRange, getLabelsXOverhang}\n  from './utils/Label';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\n\nfunction resolveXLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels\n  // which are A) distinct and B) fit on the axis without colliding with each other\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map(value => MeasuredValueLabel.getLabel({value, format, style}));\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if(!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({labels: testLabels, format, areLabelsDistinct});\n      return false;\n    }\n\n    const labelXRanges = testLabels.map(label => getLabelXRange(scale, label, (style.textAnchor || 'middle')));\n    const collisionCount = countRangeOverlaps(labelXRanges);\n    if(collisionCount) {\n      // console.log(`labels do not fit on X axis, ${collisionCount} collisions`, _.map(testLabels, 'text'));\n      attempts.push({labels: testLabels, format, areLabelsDistinct, collisionCount});\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if(!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {labels, format: goodFormat, areLabelsDistinct: true, collisionCount: 0};\n  } else {\n    // none of the sets of labels are good\n    if(!force) // if we're not forced to decide, return all the labels we tried (let someone else decide)\n      return {attempts};\n\n    // forced to decide, choose the least bad option\n    // todo warn that we couldn't find good labels\n    const distinctAttempts = attempts.filter(attempt => attempt.areLabelsDistinct);\n    return distinctAttempts.length === 0 ?\n      // super bad, we don't have any label sets with distinct labels. return the last attempt.\n      _.last(attempts) :\n      // return the attempt with the fewest collisions between distinct labels\n      _.minBy(distinctAttempts, 'collisionCount');\n  }\n}\n\nclass XAxisLabels extends React.Component {\n  static propTypes = {\n    xScale: PropTypes.func,\n    // Label Handling\n    onMouseEnterLabel: PropTypes.func,\n    onMouseMoveLabel: PropTypes.func,\n    onMouseLeaveLabel: PropTypes.func\n  };\n  static defaultProps = {\n    height: 250,\n    position: 'bottom',\n    placement: undefined,\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: '',\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: '14px',\n      lineHeight: 1,\n      textAnchor: 'middle'\n    },\n    format: undefined,\n    formats: undefined,\n    labels: undefined,\n    spacingTop: 0,\n    spacingBottom: 0,\n\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if(!props.xScale) return;\n    props = _.defaults({}, props, XAxisLabels.defaultProps);\n    return {xTickDomain: getTickDomain(props.xScale, props)};\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, XAxisLabels.defaultProps);\n    const {xScale, position, placement, distance, labelStyle} = props;\n    const labels = props.labels || XAxisLabels.getLabels(props);\n    const zeroMargin = {marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0};\n\n    if((position === 'bottom' && placement === 'above') || (position === 'top' && placement === 'below'))\n      return zeroMargin;\n\n    const marginY = _.max(labels.map(label => Math.ceil(distance + label.height)));\n    const [marginLeft, marginRight] = getLabelsXOverhang(xScale, labels, labelStyle.textAnchor || 'middle');\n\n    return _.defaults({[`margin${_.capitalize(position)}`]: marginY, marginLeft, marginRight}, zeroMargin);\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = ['YYYY', \"'YY\", 'MMM YYYY', 'M/YY'];\n    const numberFormatStrs = [\"0.[00]a\", \"0,0\", \"0.[0]\", \"0.[00]\", \"0.[0000]\", \"0.[000000]\"];\n\n    return (scaleType === 'ordinal') ? [_.identity] :\n      (scaleType === 'time') ? timeFormatStrs :\n      numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const {tickCount, labelStyle, xScale} = _.defaults(props, {}, XAxisLabels.defaultProps);\n    const ticks = props.ticks || getScaleTicks(xScale, null, tickCount);\n    const style = _.defaults(labelStyle, XAxisLabels.defaultProps.labelStyle);\n\n    const scaleType = inferScaleType(xScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs = (_.isArray(propsFormats) && propsFormats.length) ?\n      propsFormats : XAxisLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const {labels} = resolveXLabelsForValues(xScale, ticks, formats, style);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    const {height, xScale, position, distance, labelStyle, labelClassName, onMouseEnterLabel, onMouseMoveLabel, onMouseLeaveLabel, spacingTop, spacingBottom} = this.props;\n    const labels = this.props.labels || XAxisLabels.getLabels(this.props);\n    const placement = this.props.placement || ((position === 'top') ? 'above' : 'below');\n    const className = `chart-value-label chart-value-label-x ${labelClassName}`;\n    const transform = (position === 'bottom') ?\n      `translate(0, ${height + spacingBottom})` : `translate(0, ${-spacingTop})`;\n    // todo: position: 'zero' to position along the zero line\n\n    return <g className=\"chart-value-labels-x\" transform={transform}>\n      {labels.map((label, i) => {\n        const x = xScale(label.value);\n        const y = (placement === 'above') ?\n          -label.height - distance :\n          distance;\n        const [onMouseEnter, onMouseMove, onMouseLeave] =\n          ['onMouseEnterLabel', 'onMouseMoveLabel', 'onMouseLeaveLabel'].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback) ? _.partial(callback, _, label.value) : null;\n        });\n\n        return <g key={`x-axis-label-${i}`} {...{onMouseEnter, onMouseMove, onMouseLeave}}>\n          {/* <XAxisLabelDebugRect {...{x, y, label}}/> */}\n          <MeasuredValueLabel value={label.value} {...{x, y, className, dy: \"0.8em\", style: labelStyle}}>\n            {label.text}\n          </MeasuredValueLabel>\n        </g>;\n      })}\n    </g>;\n  }\n}\n\nclass XAxisLabelDebugRect extends React.Component {\n  render() {\n    const {x, y, label} = this.props;\n    return <rect {...{\n      x: x - (label.width / 2),\n      y: y,\n      width: label.width,\n      height: label.height,\n      fill: 'orange'\n    }} />;\n  }\n}\n\nexport default XAxisLabels;\n"]}