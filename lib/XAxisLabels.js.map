{"version":3,"sources":["../src/XAxisLabels.js"],"names":["resolveXLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","testLabels","map","getLabel","value","format","areLabelsDistinct","push","labelXRanges","label","textAnchor","collisionCount","isUndefined","distinctAttempts","filter","attempt","length","last","minBy","XAxisValueLabels","nextProps","nextState","props","height","position","distance","labelStyle","labelClassName","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","spacing","x","getLabels","placement","defaults","defaultProps","className","transform","bottom","top","i","y","callback","get","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","dy","text","tickCount","zeroMargin","left","right","marginY","max","Math","ceil","scaleType","timeFormatStrs","numberFormatStrs","identity","ticks","propsFormats","formatStrs","isArray","getDefaultFormats","Component","propTypes","object","func","undefined","nice","fontFamily","fontSize","lineHeight","XAxisLabelDebugRect","width","fill"],"mappings":"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","file":"XAxisLabels.js","sourcesContent":["import React from 'react';\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\n\nimport MeasuredValueLabel from './MeasuredValueLabel';\nimport {getScaleTicks, inferScaleType, getTickDomain} from './utils/Scale';\nimport {checkLabelsDistinct, countRangeOverlaps, makeLabelFormatters, getLabelXRange, getLabelsXOverhang}\n  from './utils/Label';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\n\nfunction resolveXLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels\n  // which are A) distinct and B) fit on the axis without colliding with each other\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map(value => MeasuredValueLabel.getLabel({value, format, style}));\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if(!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({labels: testLabels, format, areLabelsDistinct});\n      return false;\n    }\n\n    const labelXRanges = testLabels.map(label => getLabelXRange(scale, label, (style.textAnchor || 'middle')));\n    const collisionCount = countRangeOverlaps(labelXRanges);\n    if(collisionCount) {\n      // console.log(`labels do not fit on X axis, ${collisionCount} collisions`, _.map(testLabels, 'text'));\n      attempts.push({labels: testLabels, format, areLabelsDistinct, collisionCount});\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if(!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {labels, format: goodFormat, areLabelsDistinct: true, collisionCount: 0};\n  } else {\n    // none of the sets of labels are good\n    if(!force) // if we're not forced to decide, return all the labels we tried (let someone else decide)\n      return {attempts};\n\n    // forced to decide, choose the least bad option\n    // todo warn that we couldn't find good labels\n    const distinctAttempts = attempts.filter(attempt => attempt.areLabelsDistinct);\n    return distinctAttempts.length === 0 ?\n      // super bad, we don't have any label sets with distinct labels. return the last attempt.\n      _.last(attempts) :\n      // return the attempt with the fewest collisions between distinct labels\n      _.minBy(distinctAttempts, 'collisionCount');\n  }\n}\n\nclass XAxisValueLabels extends React.Component {\n  static propTypes = {\n    scale: PropTypes.object,\n    // Label Handling\n    onMouseEnterLabel: PropTypes.func,\n    onMouseMoveLabel: PropTypes.func,\n    onMouseLeaveLabel: PropTypes.func\n  };\n  static defaultProps = {\n    height: 250,\n    position: 'bottom',\n    placement: undefined,\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: '',\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: '14px',\n      lineHeight: 1,\n      textAnchor: 'middle'\n    },\n    format: undefined,\n    formats: undefined,\n    labels: undefined,\n    spacing: {top: 0, bottom: 0, left: 0, right: 0}\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if(!_.get(props, 'scale.x')) return;\n    props = _.defaults({}, props, XAxisValueLabels.defaultProps);\n    return {x: getTickDomain(props.scale.x, props)};\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, XAxisValueLabels.defaultProps);\n    const {position, placement, distance, tickCount, labelStyle} = props;\n    const scale = props.scale.x;\n    const labels = props.labels || XAxisValueLabels.getLabels(props);\n    const zeroMargin = {top: 0, bottom: 0, left: 0, right: 0};\n\n    if((position === 'bottom' && placement === 'above') || (position == 'top' && placement === 'below'))\n      return zeroMargin;\n\n    const marginY = _.max(labels.map(label => Math.ceil(distance + label.height)));\n    const [left, right] = getLabelsXOverhang(scale, labels, labelStyle.textAnchor || 'middle');\n\n    return _.defaults({[position] : marginY, left, right}, zeroMargin);\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = ['YYYY', \"'YY\", 'MMM YYYY', 'M/YY'];\n    const numberFormatStrs = [\"0.[00]a\", \"0,0\", \"0.[0]\", \"0.[00]\", \"0.[0000]\", \"0.[000000]\"];\n\n    return (scaleType === 'ordinal') ? [_.identity] :\n      (scaleType === 'time') ? timeFormatStrs :\n      numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const {tickCount, labelStyle} = _.defaults(props, {}, XAxisValueLabels.defaultProps);\n    const scale = props.scale.x;\n    const ticks = props.ticks || getScaleTicks(scale, null, tickCount);\n    const style = _.defaults(labelStyle, XAxisValueLabels.defaultProps.labelStyle);\n\n    const scaleType = inferScaleType(scale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs = (_.isArray(propsFormats) && propsFormats.length) ?\n      propsFormats : XAxisValueLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const {labels} = resolveXLabelsForValues(scale, ticks, formats, style);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    const {height, position, distance, labelStyle, labelClassName, onMouseEnterLabel, onMouseMoveLabel, onMouseLeaveLabel, spacing} = this.props;\n    const scale = this.props.scale.x;\n    const labels = this.props.labels || XAxisValueLabels.getLabels(this.props);\n    const placement = this.props.placement || ((position === 'top') ? 'above' : 'below');\n    const style = _.defaults(labelStyle, XAxisValueLabels.defaultProps.labelStyle);\n    const className = `chart-value-label chart-value-label-x ${labelClassName}`;\n    const transform = (position === 'bottom') ?\n      `translate(0, ${height + spacing.bottom})` : `translate(0, ${-spacing.top})`;\n    // todo: position: 'zero' to position along the zero line\n\n    return <g className=\"chart-value-labels-x\" transform={transform}>\n      {labels.map((label, i) => {\n        const x = scale(label.value);\n        const y = (placement === 'above') ?\n          -label.height - distance :\n          distance;\n        const [onMouseEnter, onMouseMove, onMouseLeave] =\n          ['onMouseEnterLabel', 'onMouseMoveLabel', 'onMouseLeaveLabel'].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback) ? _.partial(callback, _, label.value) : null;\n        });\n\n        return <g key={`x-axis-label-${i}`} {...{onMouseEnter, onMouseMove, onMouseLeave}}>\n          {/* <XAxisLabelDebugRect {...{x, y, label}}/> */}\n          <MeasuredValueLabel value={label.value} {...{x, y, className, dy:\"0.8em\", style}}>\n            {label.text}\n          </MeasuredValueLabel>\n        </g>;\n      })}\n    </g>;\n  }\n}\n\nclass XAxisLabelDebugRect extends React.Component {\n  render() {\n    const {x, y, label} = this.props;\n    return <rect {...{\n      x: x - (label.width / 2),\n      y: y,\n      width: label.width,\n      height: label.height,\n      fill: 'orange'\n    }} />;\n  }\n}\n\nexport default XAxisValueLabels;\n"]}