{"version":3,"sources":["../src/YAxisLabels.js"],"names":["resolveYLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","testLabels","map","getLabel","value","format","areLabelsDistinct","push","isUndefined","collisionCount","last","YAxisValueLabels","nextProps","nextState","props","width","position","distance","labelStyle","labelClassName","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","spacing","y","placement","className","textAnchor","defaults","defaultProps","getLabels","transform","left","right","label","i","x","callback","get","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","dy","text","zeroMargin","top","bottom","marginX","max","Math","ceil","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","length","getDefaultFormats","Component","propTypes","object","func","height","nice","fontFamily","fontSize","lineHeight","YAxisLabelDebugRect","xAdj","fill"],"mappings":"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","file":"YAxisLabels.js","sourcesContent":["import React from 'react';\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\n\nimport MeasuredValueLabel from './MeasuredValueLabel';\nimport {getScaleTicks, inferScaleType, getTickDomain} from './utils/Scale';\nimport {checkLabelsDistinct, countRangeOverlaps, makeLabelFormatters, getLabelXRange, getLabelsYOverhang}\n  from './utils/Label';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\n\nfunction resolveYLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of Y-values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels which are distinct\n  // since we currently do not support rotated axis value labels,\n  // we do not check if they fit on the axis (unlike X labels), since all Y labels will have the same height\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map(value => MeasuredValueLabel.getLabel({value, format, style}));\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if(!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({labels: testLabels, format, areLabelsDistinct});\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if(!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {labels, format: goodFormat, areLabelsDistinct: true, collisionCount: 0};\n  } else {\n    // none of the sets of labels are good\n    // if we're not forced to decide, return all the labels we tried (let someone else decide)\n    if(!force) return {attempts};\n\n    // forced to decide, choose the least bad option\n    // super bad, we don't have any label sets with distinct labels. return the last attempt.\n    return _.last(attempts);\n  }\n}\n\nclass YAxisValueLabels extends React.Component {\n  static propTypes = {\n    scale: PropTypes.object,\n    // Label Handling\n    onMouseEnterLabel: PropTypes.func,\n    onMouseMoveLabel: PropTypes.func,\n    onMouseLeaveLabel: PropTypes.func\n    // placement: undefined,\n    // format: undefined,\n    // formats: undefined,\n    // labels: undefined\n  };\n  static defaultProps = {\n    height: 250,\n    width: 400,\n    position: 'left',\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: '',\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: '14px',\n      lineHeight: 1,\n      textAnchor: 'end'\n    },\n    spacing: {top: 0, bottom: 0, left: 0, right: 0}\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if(!_.get(props, 'scale.y')) return;\n    props = _.defaults({}, props, YAxisValueLabels.defaultProps);\n    return {y: getTickDomain(props.scale.y, props)};\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, YAxisValueLabels.defaultProps);\n    const {position, placement, distance, labelStyle} = props;\n    const scale = props.scale.y;\n    const labels = props.labels || YAxisValueLabels.getLabels(props);\n    const zeroMargin = {top: 0, bottom: 0, left: 0, right: 0};\n\n    if((position === 'left' && placement === 'after') || (position == 'right' && placement === 'before'))\n      return zeroMargin;\n\n    const marginX = _.max(labels.map(label => Math.ceil(distance + label.width)));\n    const [top, bottom] = getLabelsYOverhang(scale, labels, 'middle');\n\n    return _.defaults({[position] : marginX, top, bottom}, zeroMargin);\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = ['YYYY', 'YY', 'MMM YYYY', 'M/YY'];\n    const numberFormatStrs = [\"0.[00]a\", \"0,0\", \"0.[0]\", \"0.[00]\", \"0.[0000]\", \"0.[000000]\"];\n\n    return (scaleType === 'ordinal') ? [_.identity] :\n      (scaleType === 'time') ? timeFormatStrs :\n        numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const {tickCount, labelStyle} = _.defaults(props, {}, YAxisValueLabels.defaultProps);\n    const scale = props.scale.y;\n    const ticks = props.ticks || getScaleTicks(scale, null, tickCount);\n    const style = _.defaults(labelStyle, YAxisValueLabels.defaultProps.labelStyle);\n\n    const scaleType = inferScaleType(scale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs = (_.isArray(propsFormats) && propsFormats.length) ?\n      propsFormats : YAxisValueLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const {labels} = resolveYLabelsForValues(scale, ticks, formats, style);\n    // console.log('resolveYLabelsForValues took ', performance.now() - start);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    // todo: position: 'zero' prop to position along the zero line\n    const {width, position, distance, labelStyle, labelClassName, onMouseEnterLabel, onMouseMoveLabel, onMouseLeaveLabel, spacing} = this.props;\n    const scale = this.props.scale.y;\n    const placement = this.props.placement || ((position === 'left') ? 'before' : 'after');\n    const className = `chart-value-label chart-value-label-y ${labelClassName}`;\n    const textAnchor = (placement === 'before') ? 'end' : 'start';\n    const style = _.defaults({textAnchor}, labelStyle, YAxisValueLabels.defaultProps.labelStyle);\n    const labels = this.props.labels || YAxisValueLabels.getLabels(this.props);\n    const transform = (position === 'left') ?\n      `translate(${-spacing.left}, 0)` : `translate(${width + spacing.right}, 0)`;\n\n    return <g className=\"chart-value-labels-y\" transform={transform}>\n      {labels.map((label, i) => {\n        const y = scale(label.value);\n        const x = (placement === 'before') ? -distance : distance;\n         \n        const [onMouseEnter, onMouseMove, onMouseLeave] =\n          ['onMouseEnterLabel', 'onMouseMoveLabel', 'onMouseLeaveLabel'].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback) ? _.partial(callback, _, label.value) : null;\n        });\n\n        return <g key={`x-axis-label-${i}`} {...{onMouseEnter, onMouseMove, onMouseLeave}}>\n          {/* <YAxisLabelDebugRect {...{x, y, label, style}}/> */}\n          <MeasuredValueLabel value={label.value} {...{x, y, className, dy:\"0.35em\", style}}>\n            {label.text}\n          </MeasuredValueLabel>\n        </g>;\n      })}\n    </g>;\n  }\n}\n\nclass YAxisLabelDebugRect extends React.Component {\n  render() {\n    const {x, y, label, style} = this.props;\n    const xAdj = (style.textAnchor === 'end') ? x - label.width : x;\n    return <rect {...{\n      x: xAdj,\n      y: y - (label.height / 2),\n      width: label.width,\n      height: label.height,\n      fill: 'orange'\n    }} />;\n  }\n}\n\nexport default YAxisValueLabels;\n"]}