{"version":3,"sources":["../src/YAxisLabels.js"],"names":["resolveYLabelsForValues","scale","values","formats","style","force","labels","attempts","goodFormat","find","testLabels","map","getLabel","value","format","areLabelsDistinct","push","isUndefined","collisionCount","last","YAxisLabels","nextProps","nextState","props","width","yScale","position","distance","labelStyle","labelClassName","onMouseEnterLabel","onMouseMoveLabel","onMouseLeaveLabel","spacingLeft","spacingRight","placement","className","textAnchor","defaults","defaultProps","getLabels","transform","label","i","y","x","callback","get","eventName","isFunction","partial","onMouseEnter","onMouseMove","onMouseLeave","dy","text","yTickDomain","zeroMargin","marginTop","marginBottom","marginLeft","marginRight","marginX","max","Math","ceil","capitalize","scaleType","timeFormatStrs","numberFormatStrs","identity","tickCount","ticks","propsFormats","formatStrs","isArray","length","getDefaultFormats","Component","propTypes","func","height","number","oneOf","nice","bool","array","string","object","fontFamily","fontSize","lineHeight","YAxisLabelDebugRect","xAdj","fill"],"mappings":"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","file":"YAxisLabels.js","sourcesContent":["import React from 'react';\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\n\nimport MeasuredValueLabel from './MeasuredValueLabel';\nimport {getScaleTicks, inferScaleType, getTickDomain} from './utils/Scale';\nimport {checkLabelsDistinct, countRangeOverlaps, makeLabelFormatters, getLabelXRange, getLabelsYOverhang}\n  from './utils/Label';\nimport xyPropsEqual from './utils/xyPropsEqual';\n\n\nfunction resolveYLabelsForValues(scale, values, formats, style, force = true) {\n  // given a set of Y-values to label, and a list of formatters to try,\n  // find the first formatter that produces a set of labels which are distinct\n  // since we currently do not support rotated axis value labels,\n  // we do not check if they fit on the axis (unlike X labels), since all Y labels will have the same height\n  // returns the formatter and the generated labels\n\n  let labels;\n  let attempts = [];\n  const goodFormat = _.find(formats, format => {\n    const testLabels = values.map(value => MeasuredValueLabel.getLabel({value, format, style}));\n\n    const areLabelsDistinct = checkLabelsDistinct(testLabels);\n    if(!areLabelsDistinct) {\n      // console.log('labels are not distinct', _.map(testLabels, 'text'));\n      attempts.push({labels: testLabels, format, areLabelsDistinct});\n      return false;\n    }\n\n    labels = testLabels;\n    return true;\n  });\n\n  if(!_.isUndefined(goodFormat)) {\n    // found labels which work, return them\n    return {labels, format: goodFormat, areLabelsDistinct: true, collisionCount: 0};\n  } else {\n    // none of the sets of labels are good\n    // if we're not forced to decide, return all the labels we tried (let someone else decide)\n    if(!force) return {attempts};\n\n    // forced to decide, choose the least bad option\n    // super bad, we don't have any label sets with distinct labels. return the last attempt.\n    return _.last(attempts);\n  }\n}\n\nclass YAxisLabels extends React.Component {\n  static propTypes = {\n    yScale: PropTypes.func,\n    height: PropTypes.number,\n    width: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'right']),\n    placement: PropTypes.oneOf(['before', 'after']),\n    distance: PropTypes.number,\n    nice: PropTypes.bool,\n    tickCount: PropTypes.number,\n    ticks: PropTypes.array,\n    labelClassName: PropTypes.string,\n    labelStyle: PropTypes.object,\n    spacingLeft: PropTypes.number,\n    spacingRight: PropTypes.number,\n    // Label Handling\n    onMouseEnterLabel: PropTypes.func,\n    onMouseMoveLabel: PropTypes.func,\n    onMouseLeaveLabel: PropTypes.func\n    // format: undefined,\n    // formats: undefined,\n    // labels: undefined\n  };\n  static defaultProps = {\n    height: 250,\n    width: 400,\n    position: 'left',\n    distance: 4,\n    nice: true,\n    tickCount: 10,\n    ticks: null,\n    labelClassName: '',\n    labelStyle: {\n      fontFamily: \"Helvetica, sans-serif\",\n      fontSize: '14px',\n      lineHeight: 1,\n      textAnchor: 'end'\n    },\n    spacingLeft: 0,\n    spacingRight: 0\n  };\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return !xyPropsEqual(this.props, nextProps);\n  }\n\n  static getTickDomain(props) {\n    if(!props.yScale) return;\n    props = _.defaults({}, props, YAxisLabels.defaultProps);\n    return {yTickDomain: getTickDomain(props.yScale, props)};\n  }\n\n  static getMargin(props) {\n    props = _.defaults({}, props, YAxisLabels.defaultProps);\n    const {yScale, position, placement, distance, labelStyle} = props;\n    const labels = props.labels || YAxisLabels.getLabels(props);\n    const zeroMargin = {marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0};\n\n    if((position === 'left' && placement === 'after') || (position === 'right' && placement === 'before'))\n      return zeroMargin;\n\n    const marginX = _.max(labels.map(label => Math.ceil(distance + label.width)));\n    const [marginTop, marginBottom] = getLabelsYOverhang(yScale, labels, 'middle');\n\n    return _.defaults({[`margin${_.capitalize(position)}`]: marginX, marginTop, marginBottom}, zeroMargin);\n  }\n\n  static getDefaultFormats(scaleType) {\n    const timeFormatStrs = ['YYYY', \"'YY\", 'MMM YYYY', 'M/YY'];\n    const numberFormatStrs = [\"0.[00]a\", \"0,0\", \"0.[0]\", \"0.[00]\", \"0.[0000]\", \"0.[000000]\"];\n\n    return (scaleType === 'ordinal') ? [_.identity] :\n      (scaleType === 'time') ? timeFormatStrs :\n        numberFormatStrs;\n  }\n\n  static getLabels(props) {\n    const {tickCount, labelStyle, yScale} = _.defaults(props, {}, YAxisLabels.defaultProps);\n    const ticks = props.ticks || getScaleTicks(yScale, null, tickCount);\n    const style = _.defaults(labelStyle, YAxisLabels.defaultProps.labelStyle);\n\n    const scaleType = inferScaleType(yScale);\n    const propsFormats = props.format ? [props.format] : props.formats;\n    const formatStrs = (_.isArray(propsFormats) && propsFormats.length) ?\n      propsFormats : YAxisLabels.getDefaultFormats(scaleType);\n    const formats = makeLabelFormatters(formatStrs, scaleType);\n\n    // todo resolve ticks also\n    // if there are so many ticks that no combination of labels can fit on the axis,\n    // nudge down the tickCount and try again\n    // doing this will require communicating the updated ticks/tickCount back to the parent element...\n\n    const {labels} = resolveYLabelsForValues(yScale, ticks, formats, style);\n    // console.log('resolveYLabelsForValues took ', performance.now() - start);\n    // console.log('found labels', labels);\n    return labels;\n  }\n\n  render() {\n    // todo: position: 'zero' prop to position along the zero line\n    const {width, yScale, position, distance, labelStyle, labelClassName, onMouseEnterLabel, onMouseMoveLabel, onMouseLeaveLabel, spacingLeft, spacingRight} = this.props;\n    const placement = this.props.placement || ((position === 'left') ? 'before' : 'after');\n    const className = `chart-value-label chart-value-label-y ${labelClassName}`;\n    const textAnchor = (placement === 'before') ? 'end' : 'start';\n    const style = _.defaults({textAnchor}, labelStyle, YAxisLabels.defaultProps.labelStyle);\n    const labels = this.props.labels || YAxisLabels.getLabels(this.props);\n    const transform = (position === 'left') ?\n      `translate(${-spacingLeft}, 0)` : `translate(${width + spacingRight}, 0)`;\n\n    return <g className=\"chart-value-labels-y\" transform={transform}>\n      {labels.map((label, i) => {\n        const y = yScale(label.value);\n        const x = (placement === 'before') ? -distance : distance;\n         \n        const [onMouseEnter, onMouseMove, onMouseLeave] =\n          ['onMouseEnterLabel', 'onMouseMoveLabel', 'onMouseLeaveLabel'].map(eventName => {\n            // partially apply this bar's data point as 2nd callback argument\n            const callback = _.get(this.props, eventName);\n            return _.isFunction(callback) ? _.partial(callback, _, label.value) : null;\n        });\n\n        return <g key={`x-axis-label-${i}`} {...{onMouseEnter, onMouseMove, onMouseLeave}}>\n          {/* <YAxisLabelDebugRect {...{x, y, label, style}}/> */}\n          <MeasuredValueLabel value={label.value} {...{x, y, className, dy:\"0.35em\", style}}>\n            {label.text}\n          </MeasuredValueLabel>\n        </g>;\n      })}\n    </g>;\n  }\n}\n\nclass YAxisLabelDebugRect extends React.Component {\n  render() {\n    const {x, y, label, style} = this.props;\n    const xAdj = (style.textAnchor === 'end') ? x - label.width : x;\n    return <rect {...{\n      x: xAdj,\n      y: y - (label.height / 2),\n      width: label.width,\n      height: label.height,\n      fill: 'orange'\n    }} />;\n  }\n}\n\nexport default YAxisLabels;\n"]}