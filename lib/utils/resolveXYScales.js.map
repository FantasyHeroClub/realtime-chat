{"version":3,"sources":["../../src/utils/resolveXYScales.js"],"names":["resolveXYScales","errs","getDomain","C","componentName","Component","displayName","hasScaleFor","scalesObj","key","isObject","hasPaddingFor","paddingObj","isNumber","hasXYScales","scale","x","y","hasXYDomains","domain","hasXYScaleTypes","scaleType","isString","hasAllMargins","margin","marginKeys","every","has","k","hasAllSpacing","spacing","spacingKeys","mapOverChildren","children","iteratee","iterateeArgs","isFunction","Error","compact","Children","map","child","isValidElement","props","type","omitNullUndefined","obj","omitBy","isUndefined","v","isNull","ComposedComponent","_makeScales","width","height","invertScale","nice","tickCount","ticks","innerChartWidth","innerChartHeight","range","left","top","fromPairs","kScale","reverse","propsScaleType","getScaleType","componentScaleType","assign","domainScaleType","undefined","isArray","data","datasets","datasetScaleType","kAccessor","get","toUpperCase","kDataType","kScaleType","count","childScaleTypes","_resolveScaleType","bind","childScaleType","kScaleTypes","uniq","length","propsDomain","componentDomain","datasetDomain","dataType","kDomain","childDomains","_resolveDomain","childDomain","getTickDomain","childTickDomains","_resolveTickDomain","tickDomain","kChildTickDomains","kTickDomain","propsSpacing","getSpacing","componentSpacing","childSpacings","_resolveSpacing","childSpacing","propsMargin","getMargin","componentMargin","childMargins","_resolveMargin","childMargin","scaleFromProps","scaleOptions","padding","tempScale","forEach","defaults","bottom","right","passedProps","defaultProps"],"mappings":"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","file":"resolveXYScales.js","sourcesContent":["import _ from 'lodash';\nimport {scalePoint} from 'd3';\nimport React from 'react';\nimport invariant from 'invariant';\n\nimport {\n  makeAccessor,\n  domainFromDatasets,\n  domainFromData,\n  inferDatasetsType,\n  datasetsFromPropsOrDescendants,\n  combineDomains,\n  combineBorderObjects,\n  isValidDomain\n} from './Data';\n\nimport {\n  scaleTypeFromDataType,\n  dataTypeFromScaleType,\n  inferDataTypeFromDomain,\n  initScale,\n  isValidScale\n} from './Scale';\n\nimport {innerRangeX, innerRangeY, innerWidth, innerHeight} from './Margin';\n\n/**\n * `resolveXYScales` is a higher-order-component.\n *\n * @param {Component} Component - The React Component (class) which should be wrapped by this HOC\n * @returns {Component} - A Component which auto-resolves XY scales from given props\n*/\n\nconst errs = {\n  getDomain: (C) =>\n    `Components enhanced by resolveXYScales must have a static getDomain method, ${componentName(C)} does not have one`\n};\nfunction componentName(Component) {\n  return Component.displayName || \"Component wrapped by resolveXYScales\";\n}\nfunction hasScaleFor(scalesObj, key) {\n  return _.isObject(scalesObj) && isValidScale(scalesObj[key]);\n}\nfunction hasPaddingFor(paddingObj, key) {\n  return _.isObject(paddingObj) && _.isNumber(paddingObj[key]);\n}\nfunction hasXYScales(scale) {\n  return _.isObject(scale) && isValidScale(scale.x) && isValidScale(scale.y);\n}\nfunction hasXYDomains(domain) {\n  return _.isObject(domain) && isValidDomain(domain.x) && isValidDomain(domain.y);\n}\nfunction hasXYScaleTypes(scaleType) {\n  return _.isObject(scaleType) && _.isString(scaleType.x) && _.isString(scaleType.y);\n}\nfunction hasAllMargins(margin) {\n  const marginKeys = ['top', 'bottom', 'left', 'right'];\n  return _.isObject(margin) && _.every(marginKeys, k => _.has(margin, k));\n}\nfunction hasAllSpacing(spacing) {\n  const spacingKeys = ['top', 'bottom', 'left', 'right'];\n  return _.isObject(spacing) && _.every(spacingKeys, k => _.has(spacing, k));\n}\n\nfunction mapOverChildren(children, iteratee, ...iterateeArgs) {\n  // loop over all children (react elements) and call iteratee (a function) on each one\n  // iteratee is called with parameters (child.props, child.type, ...iterateeArgs)\n  if(!_.isFunction(iteratee)) throw new Error('mapOverChildren iteratee must be a function');\n\n  return _.compact(React.Children.map(children, child => {\n    if(!child || !React.isValidElement(child)) return null;\n    return iteratee(child.props, child.type, ...iterateeArgs);\n  }));\n}\nfunction omitNullUndefined(obj) {\n  return _.omitBy(obj, v => _.isUndefined(v) || _.isNull(v));\n}\n\n// not currently being used but potentially has some learnings\n// function resolveXYPropsOnComponentOrChildren(propKeys, props, reducers = {}, validators = {}, result = {}) {\n//   const isDone = (o) => (_.every(propKeys, k => _.isObject(o[k]) && _.every(['x', 'y'], xy => _.has(o[k][xy]))));\n//   result = _.pick({...props, ...result}, propKeys);\n\n//   let resolved = {};\n//   _.forEach(propKeys, propKey => {\n//     _.forEach(['x', 'y'], k => {\n//       const isValid = validators[propKey] || (() => true);\n//       if(_.isObject(props[propKey]) && _.has(props[propKey], k) && isValid(props[propKey][k])) {\n//         if(!_.has(result, propKey)) result[propKey] = {};\n//         result[propKey][k] = props[propKey][k];\n//       }\n//     });\n//   });\n\n//   if(isDone(result)) return result;\n\n//   if(React.Children.count(props.children)) {\n//     let childProps = mapOverChildren(props.children, resolveXYPropsOnComponentOrChildren, propKeys, 'props', result);\n//     React.Children.forEach(props.children, child => {\n//       if(!child) return;\n//       childProps.push(resolveXYPropsOnComponentOrChildren(propKeys, child.props, result));\n//     });\n//       let childDomains = [];\n//       React.Children.forEach(props.children, child => {\n//         childDomains = childDomains.concat(this._resolveDomain(child.props, child.type, scaleType));\n//       });\n\n//       console.log('combining domains', childDomains);\n//       const childDomain =  _.fromPairs(['x', 'y'].map(k => {\n//         console.log(_.compact(_.map(childDomains, k)), scaleType[k]);\n//         const kDomain = combineDomains(_.compact(_.map(childDomains, k)), dataTypeFromScaleType(scaleType[k]));\n//         console.log(kDomain);\n//         return [k, kDomain];\n//       }));\n//       console.log('combined domains', childDomain);\n\n//       domain = _.assign(childDomain, domain);\n//       return domain;\n//   }\n\n//   propKeys.forEach(k => {\n//     result[propKeys] = props\n//   })\n// }\n\n\n\nexport default function resolveXYScales(ComposedComponent) {\n  return class extends React.Component {\n    static defaultProps = _.defaults(ComposedComponent.defaultProps, {\n      invertScale: {x: false, y: false},\n    });\n\n    // todo better way for HOC's to pass statics through?\n    static getScaleType = ComposedComponent.getScaleType; \n    static getSpacing = ComposedComponent.getSpacing;\n    static getDomain = ComposedComponent.getDomain;\n    static getMargin = ComposedComponent.getMargin;\n\n    _resolveScaleType(props, Component) {\n      const propsScaleType = props.scaleType || {};\n\n      // short-circuit if all scale types provided\n      if(hasXYScaleTypes(propsScaleType)) return propsScaleType;\n\n      // start with any scale types in props, try to resolve the rest\n      let scaleType = omitNullUndefined(propsScaleType);\n\n      // if Component provides a custom static getScaleType method\n      // use it to determine remaining scale types\n      if(_.isFunction(Component.getScaleType)) {\n        const componentScaleType = omitNullUndefined(Component.getScaleType(props));\n        scaleType = _.assign(componentScaleType, scaleType);\n        if(hasXYScaleTypes(scaleType)) return scaleType;\n      }\n\n      // todo infer scaleType from domain?\n      // if component has domain props,\n      // infer the data type, & use that to get scale type\n      if(_.isObject(props.domain) && (isValidDomain(props.domain.x) || isValidDomain(props.domain.y))) {\n        // console.log('inferring scale type from domain');\n        const domainScaleType = _.fromPairs(['x', 'y'].map(k => {\n          const domain = props.domain[k];\n          return isValidDomain(domain) ?\n            [k, scaleTypeFromDataType(inferDataTypeFromDomain(domain))] :\n            [k, undefined];\n        }));\n        scaleType = _.assign(domainScaleType, scaleType);\n        if(hasXYScaleTypes(scaleType)) return scaleType;\n      }\n\n      // if Component has data or datasets props,\n      // infer the data type, & use that to get scale type\n      if(_.isArray(props.data) || _.isArray(props.datasets)) {\n        const datasets = _.isArray(props.datasets) ? props.datasets : [props.data];\n        const datasetScaleType = _.fromPairs(['x', 'y'].map(k => {\n          // const kAccessor = makeAccessor(_.get(props, `getValue.${k}`));\n          const kAccessor = makeAccessor(_.get(props, `get${k.toUpperCase()}`));\n          const kDataType = inferDatasetsType(datasets, kAccessor);\n          const kScaleType = scaleTypeFromDataType(kDataType);\n          return [k, kScaleType];\n        }));\n\n        scaleType = _.assign(datasetScaleType, scaleType);\n        return scaleType;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their scale types the same way\n      if(React.Children.count(props.children)) {\n        // console.log('get scaletype from children')\n        let childScaleTypes = mapOverChildren(props.children, this._resolveScaleType.bind(this));\n\n        const childScaleType =  _.fromPairs(['x', 'y'].map(k => {\n          // todo warn on multiple scale types, probably not what you want\n          const kScaleTypes = _.compact(_.uniq(_.map(childScaleTypes, k)));\n          const kScaleType = (kScaleTypes.length === 1) ? kScaleTypes[0] : \"ordinal\";\n          return [k, kScaleType];\n        }));\n\n        scaleType = _.assign(childScaleType, scaleType);\n        return scaleType;\n      }\n    }\n\n    _resolveDomain(props, Component, scaleType) {\n      const propsDomain = props.domain || {};\n\n      // short-circuit if all domains provided\n      if(hasXYDomains(propsDomain)) return propsDomain;\n\n      // start with any domains in props, and try to resolve the rest\n      let domain = omitNullUndefined(propsDomain);\n\n      // if Component provides a custom static getDomain method\n      // use it to determine remaining domains\n      if(_.isFunction(Component.getDomain)) {\n        const componentDomain = omitNullUndefined(Component.getDomain({scaleType, ...props}));\n        domain = _.assign(componentDomain, domain);\n        if(hasXYDomains(domain)) return domain;\n      }\n\n      // if Component has data or datasets props,\n      // use the default domainFromDatasets function to determine a domain from them\n      if(_.isArray(props.data) || _.isArray(props.datasets)) {\n        const datasets = _.isArray(props.datasets) ? props.datasets : [props.data];\n        const datasetDomain = _.fromPairs(['x', 'y'].map(k => {\n          // const kAccessor = makeAccessor(_.get(props, `getValue.${k}`));\n          const kAccessor = makeAccessor(_.get(props, `get${k.toUpperCase()}`));\n          const dataType = dataTypeFromScaleType(scaleType[k]);\n          const kDomain = domainFromDatasets(datasets, kAccessor, dataType);\n          return [k, kDomain];\n        }));\n\n        domain = _.assign(datasetDomain, domain);\n        if(hasXYDomains(domain)) return domain;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their domains the same way,\n      // and combine them into a single domain, if there are multiple\n      if(React.Children.count(props.children)) {\n        let childDomains = mapOverChildren(props.children, this._resolveDomain.bind(this), scaleType);\n\n        const childDomain =  _.fromPairs(['x', 'y'].map(k => {\n          const kDomain = combineDomains(_.compact(_.map(childDomains, k)), dataTypeFromScaleType(scaleType[k]));\n          return [k, kDomain];\n        }));\n\n        domain = _.assign(childDomain, domain);\n        return domain;\n      }\n    }\n\n    _resolveTickDomain(props, Component, scaleType, domain, scale) {\n      // todo resolve directly from ticks/tickCount props?\n      if(_.isFunction(Component.getTickDomain)) {\n        return omitNullUndefined(Component.getTickDomain({scaleType, domain, scale, ...props}));\n      }\n\n      if(React.Children.count(props.children)) {\n        let childTickDomains =\n          mapOverChildren(props.children, this._resolveTickDomain.bind(this), scaleType, domain, scale);\n\n        const tickDomain = _.fromPairs(['x', 'y'].map(k => {\n          const kChildTickDomains = _.compact(childTickDomains.map(v => _.get(v, k)));\n          const kTickDomain = kChildTickDomains.length ?\n            combineDomains(kChildTickDomains, dataTypeFromScaleType(scaleType[k])) : undefined;\n          return [k, kTickDomain];\n        }));\n        return omitNullUndefined(tickDomain);\n      }\n    }\n\n    _resolveLabels(props) {\n\n    }\n    _resolveSpacing(props, Component, scaleType, domain, scale){\n      const propsSpacing = props.spacing || {};\n\n      // short-circuit if all spacings provided\n      if(hasAllSpacing(propsSpacing)) return propsSpacing;     \n\n      let spacing = omitNullUndefined(propsSpacing);\n\n      if(_.isFunction(Component.getSpacing)) {\n        const componentSpacing = omitNullUndefined(Component.getSpacing({scaleType, domain, scale, ...props}));\n        spacing = _.assign(componentSpacing, spacing);\n        if(hasAllSpacing(spacing)) return spacing;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their spacings the same way,\n      // and combine them into a single spacing, if there are multiple\n      if(React.Children.count(props.children)) {\n        let childSpacings = mapOverChildren(props.children, this._resolveSpacing.bind(this), scaleType, domain, scale);\n\n        const childSpacing = combineBorderObjects(childSpacings);\n\n        spacing = _.assign(childSpacing, spacing);\n      }\n      return spacing;\n\n    }\n    _resolveMargin(props, Component, scaleType, domain, scale) {\n      const propsMargin = props.margin || {};\n\n      // short-circuit if all margins provided\n      if(hasAllMargins(propsMargin)) return propsMargin;\n\n      // start with any margins in props, and try to resolve the rest\n      let margin = omitNullUndefined(propsMargin);\n\n      // if Component provides a custom static getMargin method\n      // use it to determine remaining domains\n      if(_.isFunction(Component.getMargin)) {\n        const componentMargin = omitNullUndefined(Component.getMargin({scaleType, domain, scale, ...props}));\n        margin = _.assign(componentMargin, margin);\n        if(hasAllMargins(margin)) return margin;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their margins the same way,\n      // and combine them into a single margin, if there are multiple\n      if(React.Children.count(props.children)) {\n        let childMargins = mapOverChildren(props.children, this._resolveMargin.bind(this), scaleType, domain, scale);\n\n        // console.log('combining child margins', childMargins);\n        const childMargin = combineBorderObjects(childMargins);\n\n        margin = _.assign(childMargin, margin);\n      }\n      return margin;\n    }\n\n    _makeScales = ({width, height, scaleType={}, domain={}, margin={}, scale={}, spacing={}}) => {\n      const {invertScale, nice, tickCount, ticks} = this.props;\n      \n      const innerChartWidth = innerWidth(width, margin);\n      const innerChartHeight = innerHeight(height, margin);\n\n      const range = {\n        x: innerRangeX(innerChartWidth, spacing).map(v => v - (spacing.left || 0)),\n        y: innerRangeY(innerChartHeight, spacing).map(v => v - (spacing.top || 0))\n      };\n      //innerRange functions produce range (i.e. [5,20]) and map function normalizes to 0 (i.e. [0,15])\n\n      return _.fromPairs(['x', 'y'].map(k => {\n        // use existing scales if provided, otherwise create new\n        if(hasScaleFor(scale, k)) return [k, scale[k]];\n\n        // create scale from domain/range\n        const kScale = initScale(scaleType[k]).domain(domain[k]).range(range[k]);\n\n        // todo - ticks, nice and getDomain should be an axis prop instead, and axis should have getDomain\n\n        // set `nice` option to round scale domains to nicer numbers\n        // if(nice[k] && _.isFunction(kScale.nice)) kScale.nice(tickCount[k] || 10);\n\n        // extend scale domain to include custom `ticks` if passed\n        //\n        // if(ticks[k]) {\n        //   const dataType = dataTypeFromScaleType(scaleType[k]);\n        //   const tickDomain = domainFromData(ticks[k], _.identity, dataType);\n        //   kScale.domain(combineDomains([kScale.domain(), tickDomain]), dataType);\n        // }\n\n        // reverse scale domain if `invertScale` is passed\n        if(invertScale[k]) kScale.domain(kScale.domain().reverse());\n\n        return [k, kScale];\n      }));\n    };\n\n    render() {\n      const {props} = this;\n      const {width, height, nice} = props;\n      const scaleFromProps = this.props.scale || {};\n\n      // short-circuit if scales provided\n      // todo warn/throw if bad scales are passed\n      if(hasXYScales(scaleFromProps))\n        return <ComposedComponent {...this.props} />;\n\n      // scales not provided, so we have to resolve them\n      // first resolve scale types and domains\n      const scaleType = this._resolveScaleType(props, ComposedComponent);\n      const domain = this._resolveDomain(props, ComposedComponent, scaleType);\n      let scaleOptions = {width, height, scaleType, domain, margin: props.margin, scale: props.scale, padding: props.padding, spacing: props.spacing};\n      // create a temporary scale with size & domain, which may be used by the Component to calculate margin/tickDomain\n      // (eg. to create and measure labels for the scales)\n      let tempScale = this._makeScales(scaleOptions);\n\n      // getTickDomain gives children the opportunity to modify the domain to include their scale ticks\n      // (can't happen in getDomain, because it can't be done until the base domain/tempScale has been created)\n      //nice-ing happens in the getTickDomain function inside of _resolveTickDomain\n      const tickDomain = this._resolveTickDomain(props, ComposedComponent, scaleType, domain, tempScale);\n      if(_.isObject(tickDomain)) {\n        ['x', 'y'].forEach(k => {\n          const dataType = dataTypeFromScaleType(scaleType[k]);\n          if(isValidDomain(tickDomain[k], dataType))\n            domain[k] = combineDomains([domain[k], tickDomain[k]], dataType);\n        })\n      }\n      // update tempScale to use new domain before creating margins\n      tempScale = this._makeScales(scaleOptions);\n\n      // then resolve the margins\n      const margin = _.defaults(\n        this._resolveMargin(props, ComposedComponent, scaleType, domain, tempScale),\n        {top: 0, bottom: 0, left: 0, right: 0}\n      );\n\n      const spacing = _.defaults(\n        this._resolveSpacing(props, ComposedComponent, scaleType, domain, tempScale),\n        {top: 0, bottom: 0, left: 0, right: 0}\n      );\n\n      // create real scales from resolved margins\n      scaleOptions = {...scaleOptions, margin, spacing};\n      const scale = this._makeScales(scaleOptions);\n      \n      const passedProps = _.assign({}, this.props, {scale, scaleType, margin, domain, spacing});\n      return <ComposedComponent {...passedProps} />;\n\n      // todo spacing/padding\n      // todo includeZero\n      // todo purerender/shouldcomponentupdate?\n      // todo resolve margins if scales are present\n      // todo use zero for any margins which can't be resolved\n      // todo throw if cannot resolve scaleType\n      // todo throw if cannot resolve domain\n      // todo check to make sure margins didn't change after scales resolved?\n    }\n  }\n}\n"]}