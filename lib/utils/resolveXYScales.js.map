{"version":3,"sources":["../../src/utils/resolveXYScales.js"],"names":["resolveXYScales","errs","getDomain","C","componentName","Component","displayName","hasScaleFor","scalesObj","key","isObject","hasPaddingFor","paddingObj","isNumber","hasXYScales","scale","x","y","hasXYDomains","domain","hasXYScaleTypes","scaleType","isString","hasAllMargins","margin","marginKeys","every","has","k","hasAllSpacing","spacing","spacingKeys","mapOverChildren","children","iteratee","iterateeArgs","isFunction","Error","compact","Children","map","child","isValidElement","props","type","omitNullUndefined","obj","omitBy","isUndefined","v","isNull","ComposedComponent","_makeScales","width","height","invertScale","nice","tickCount","ticks","innerChartWidth","innerChartHeight","range","left","top","fromPairs","kScale","propsScaleType","getScaleType","componentScaleType","assign","domainScaleType","undefined","isArray","data","datasets","datasetScaleType","kAccessor","get","toUpperCase","kDataType","kScaleType","count","childScaleTypes","_resolveScaleType","bind","childScaleType","kScaleTypes","uniq","length","propsDomain","componentDomain","datasetDomain","dataType","kDomain","childDomains","_resolveDomain","childDomain","getTickDomain","childTickDomains","_resolveTickDomain","tickDomain","kChildTickDomains","kTickDomain","propsSpacing","getSpacing","componentSpacing","childSpacings","_resolveSpacing","childSpacing","propsMargin","getMargin","componentMargin","childMargins","_resolveMargin","childMargin","scaleFromProps","forEach","slice","reverse","scaleOptions","padding","tempScale","defaults","bottom","right","passedProps","defaultProps"],"mappings":";;;;;;;;;;kBA+HwBA,e;;AA/HxB;;;;AACA;;AACA;;;;AACA;;;;AAEA;;AAWA;;AAQA;;;;;;;;;;AAEA;;;;;;;AAOA,IAAMC,OAAO;AACXC,aAAW,mBAACC,CAAD;AAAA,4FACsEC,cAAcD,CAAd,CADtE;AAAA;AADA,CAAb;AAIA,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;AAChC,SAAOA,UAAUC,WAAV,IAAyB,sCAAhC;AACD;AACD,SAASC,WAAT,CAAqBC,SAArB,EAAgCC,GAAhC,EAAqC;AACnC,SAAO,iBAAEC,QAAF,CAAWF,SAAX,KAAyB,yBAAaA,UAAUC,GAAV,CAAb,CAAhC;AACD;AACD,SAASE,aAAT,CAAuBC,UAAvB,EAAmCH,GAAnC,EAAwC;AACtC,SAAO,iBAAEC,QAAF,CAAWE,UAAX,KAA0B,iBAAEC,QAAF,CAAWD,WAAWH,GAAX,CAAX,CAAjC;AACD;AACD,SAASK,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,SAAO,iBAAEL,QAAF,CAAWK,KAAX,KAAqB,yBAAaA,MAAMC,CAAnB,CAArB,IAA8C,yBAAaD,MAAME,CAAnB,CAArD;AACD;AACD,SAASC,YAAT,CAAsBC,MAAtB,EAA8B;AAC5B,SAAO,iBAAET,QAAF,CAAWS,MAAX,KAAsB,yBAAcA,OAAOH,CAArB,CAAtB,IAAiD,yBAAcG,OAAOF,CAArB,CAAxD;AACD;AACD,SAASG,eAAT,CAAyBC,SAAzB,EAAoC;AAClC,SAAO,iBAAEX,QAAF,CAAWW,SAAX,KAAyB,iBAAEC,QAAF,CAAWD,UAAUL,CAArB,CAAzB,IAAoD,iBAAEM,QAAF,CAAWD,UAAUJ,CAArB,CAA3D;AACD;AACD,SAASM,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,MAAMC,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,MAAlB,EAA0B,OAA1B,CAAnB;AACA,SAAO,iBAAEf,QAAF,CAAWc,MAAX,KAAsB,iBAAEE,KAAF,CAAQD,UAAR,EAAoB;AAAA,WAAK,iBAAEE,GAAF,CAAMH,MAAN,EAAcI,CAAd,CAAL;AAAA,GAApB,CAA7B;AACD;AACD,SAASC,aAAT,CAAuBC,OAAvB,EAAgC;AAC9B,MAAMC,cAAc,CAAC,KAAD,EAAQ,QAAR,EAAkB,MAAlB,EAA0B,OAA1B,CAApB;AACA,SAAO,iBAAErB,QAAF,CAAWoB,OAAX,KAAuB,iBAAEJ,KAAF,CAAQK,WAAR,EAAqB;AAAA,WAAK,iBAAEJ,GAAF,CAAMG,OAAN,EAAeF,CAAf,CAAL;AAAA,GAArB,CAA9B;AACD;;AAED,SAASI,eAAT,CAAyBC,QAAzB,EAAmCC,QAAnC,EAA8D;AAAA,oCAAdC,YAAc;AAAdA,gBAAc;AAAA;;AAC5D;AACA;AACA,MAAG,CAAC,iBAAEC,UAAF,CAAaF,QAAb,CAAJ,EAA4B,MAAM,IAAIG,KAAJ,CAAU,6CAAV,CAAN;;AAE5B,SAAO,iBAAEC,OAAF,CAAU,gBAAMC,QAAN,CAAeC,GAAf,CAAmBP,QAAnB,EAA6B,iBAAS;AACrD,QAAG,CAACQ,KAAD,IAAU,CAAC,gBAAMC,cAAN,CAAqBD,KAArB,CAAd,EAA2C,OAAO,IAAP;AAC3C,WAAOP,2BAASO,MAAME,KAAf,EAAsBF,MAAMG,IAA5B,SAAqCT,YAArC,EAAP;AACD,GAHgB,CAAV,CAAP;AAID;AACD,SAASU,iBAAT,CAA2BC,GAA3B,EAAgC;AAC9B,SAAO,iBAAEC,MAAF,CAASD,GAAT,EAAc;AAAA,WAAK,iBAAEE,WAAF,CAAcC,CAAd,KAAoB,iBAAEC,MAAF,CAASD,CAAT,CAAzB;AAAA,GAAd,CAAP;AACD;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAIe,SAASjD,eAAT,CAAyBmD,iBAAzB,EAA4C;AAAA;;AACzD;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA,wLA+MEC,WA/MF,GA+MgB,iBAA+E;AAAA,YAA7EC,KAA6E,SAA7EA,KAA6E;AAAA,YAAtEC,MAAsE,SAAtEA,MAAsE;AAAA,oCAA9DjC,SAA8D;AAAA,YAA9DA,SAA8D,mCAApD,EAAoD;AAAA,iCAAhDF,MAAgD;AAAA,YAAhDA,MAAgD,gCAAzC,EAAyC;AAAA,iCAArCK,MAAqC;AAAA,YAArCA,MAAqC,gCAA9B,EAA8B;AAAA,gCAA1BT,KAA0B;AAAA,YAA1BA,KAA0B,+BAApB,EAAoB;AAAA,kCAAhBe,OAAgB;AAAA,YAAhBA,OAAgB,iCAAR,EAAQ;AAAA,0BAC7C,MAAKa,KADwC;AAAA,YACpFY,WADoF,eACpFA,WADoF;AAAA,YACvEC,IADuE,eACvEA,IADuE;AAAA,YACjEC,SADiE,eACjEA,SADiE;AAAA,YACtDC,KADsD,eACtDA,KADsD;;;AAG3F,YAAMC,kBAAkB,wBAAWN,KAAX,EAAkB7B,MAAlB,CAAxB;AACA,YAAMoC,mBAAmB,yBAAYN,MAAZ,EAAoB9B,MAApB,CAAzB;;AAEA,YAAMqC,QAAQ;AACZ7C,aAAG,yBAAY2C,eAAZ,EAA6B7B,OAA7B,EAAsCU,GAAtC,CAA0C;AAAA,mBAAKS,KAAKnB,QAAQgC,IAAR,IAAgB,CAArB,CAAL;AAAA,WAA1C,CADS;AAEZ7C,aAAG,yBAAY2C,gBAAZ,EAA8B9B,OAA9B,EAAuCU,GAAvC,CAA2C;AAAA,mBAAKS,KAAKnB,QAAQiC,GAAR,IAAe,CAApB,CAAL;AAAA,WAA3C;AAFS,SAAd;AAIA;;AAEA,eAAO,iBAAEC,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACrC;AACA,cAAGjC,YAAYQ,KAAZ,EAAmBa,CAAnB,CAAH,EAA0B,OAAO,CAACA,CAAD,EAAIb,MAAMa,CAAN,CAAJ,CAAP;;AAE1B;AACA,cAAMqC,SAAS,sBAAU5C,UAAUO,CAAV,CAAV,EAAwBT,MAAxB,CAA+BA,OAAOS,CAAP,CAA/B,EAA0CiC,KAA1C,CAAgDA,MAAMjC,CAAN,CAAhD,CAAf;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAO,CAACA,CAAD,EAAIqC,MAAJ,CAAP;AACD,SAzBkB,CAAZ,CAAP;AA0BD,OArPH;AAAA;;AAKE;;;AALF;AAAA;AAAA,wCAWoBtB,KAXpB,EAW2BtC,SAX3B,EAWsC;AAClC,YAAM6D,iBAAiBvB,MAAMtB,SAAN,IAAmB,EAA1C;;AAEA;AACA,YAAGD,gBAAgB8C,cAAhB,CAAH,EAAoC,OAAOA,cAAP;;AAEpC;AACA,YAAI7C,YAAYwB,kBAAkBqB,cAAlB,CAAhB;;AAEA;AACA;AACA,YAAG,iBAAE9B,UAAF,CAAa/B,UAAU8D,YAAvB,CAAH,EAAyC;AACvC,cAAMC,qBAAqBvB,kBAAkBxC,UAAU8D,YAAV,CAAuBxB,KAAvB,CAAlB,CAA3B;AACAtB,sBAAY,iBAAEgD,MAAF,CAASD,kBAAT,EAA6B/C,SAA7B,CAAZ;AACA,cAAGD,gBAAgBC,SAAhB,CAAH,EAA+B,OAAOA,SAAP;AAChC;;AAED;AACA;AACA;AACA,YAAG,iBAAEX,QAAF,CAAWiC,MAAMxB,MAAjB,MAA6B,yBAAcwB,MAAMxB,MAAN,CAAaH,CAA3B,KAAiC,yBAAc2B,MAAMxB,MAAN,CAAaF,CAA3B,CAA9D,CAAH,EAAiG;AAC/F;AACA,cAAMqD,kBAAkB,iBAAEN,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACtD,gBAAMrB,SAASwB,MAAMxB,MAAN,CAAaS,CAAb,CAAf;AACA,mBAAO,yBAAcT,MAAd,IACL,CAACS,CAAD,EAAI,kCAAsB,oCAAwBT,MAAxB,CAAtB,CAAJ,CADK,GAEL,CAACS,CAAD,EAAI2C,SAAJ,CAFF;AAGD,WALmC,CAAZ,CAAxB;AAMAlD,sBAAY,iBAAEgD,MAAF,CAASC,eAAT,EAA0BjD,SAA1B,CAAZ;AACA,cAAGD,gBAAgBC,SAAhB,CAAH,EAA+B,OAAOA,SAAP;AAChC;;AAED;AACA;AACA,YAAG,iBAAEmD,OAAF,CAAU7B,MAAM8B,IAAhB,KAAyB,iBAAED,OAAF,CAAU7B,MAAM+B,QAAhB,CAA5B,EAAuD;AACrD,cAAMA,WAAW,iBAAEF,OAAF,CAAU7B,MAAM+B,QAAhB,IAA4B/B,MAAM+B,QAAlC,GAA6C,CAAC/B,MAAM8B,IAAP,CAA9D;AACA,cAAME,mBAAmB,iBAAEX,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACvD;AACA,gBAAMoC,YAAY,wBAAa,iBAAEC,GAAF,CAAMlC,KAAN,UAAmBf,EAAEkD,WAAF,EAAnB,CAAb,CAAlB;AACA,gBAAMC,YAAY,6BAAkBL,QAAlB,EAA4BE,SAA5B,CAAlB;AACA,gBAAMI,aAAa,kCAAsBD,SAAtB,CAAnB;AACA,mBAAO,CAACnD,CAAD,EAAIoD,UAAJ,CAAP;AACD,WANoC,CAAZ,CAAzB;;AAQA3D,sBAAY,iBAAEgD,MAAF,CAASM,gBAAT,EAA2BtD,SAA3B,CAAZ;AACA,iBAAOA,SAAP;AACD;;AAED;AACA;AACA,YAAG,gBAAMkB,QAAN,CAAe0C,KAAf,CAAqBtC,MAAMV,QAA3B,CAAH,EAAyC;AACvC;AACA,cAAIiD,kBAAkBlD,gBAAgBW,MAAMV,QAAtB,EAAgC,KAAKkD,iBAAL,CAAuBC,IAAvB,CAA4B,IAA5B,CAAhC,CAAtB;;AAEA,cAAMC,iBAAkB,iBAAErB,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACtD;AACA,gBAAM8C,cAAc,iBAAEhD,OAAF,CAAU,iBAAEiD,IAAF,CAAO,iBAAE/C,GAAF,CAAM0C,eAAN,EAAuBtD,CAAvB,CAAP,CAAV,CAApB;AACA,gBAAMoD,aAAcM,YAAYE,MAAZ,KAAuB,CAAxB,GAA6BF,YAAY,CAAZ,CAA7B,GAA8C,SAAjE;AACA,mBAAO,CAAC1D,CAAD,EAAIoD,UAAJ,CAAP;AACD,WALmC,CAAZ,CAAxB;;AAOA3D,sBAAY,iBAAEgD,MAAF,CAASgB,cAAT,EAAyBhE,SAAzB,CAAZ;AACA,iBAAOA,SAAP;AACD;AACF;AA3EH;AAAA;AAAA,qCA6EiBsB,KA7EjB,EA6EwBtC,SA7ExB,EA6EmCgB,SA7EnC,EA6E8C;AAC1C,YAAMoE,cAAc9C,MAAMxB,MAAN,IAAgB,EAApC;;AAEA;AACA,YAAGD,aAAauE,WAAb,CAAH,EAA8B,OAAO,EAACzE,GAAGyE,YAAYzE,CAAhB,EAAmBC,GAAGwE,YAAYxE,CAAlC,EAAP;;AAE9B;AACA,YAAIE,SAAS0B,kBAAkB4C,WAAlB,CAAb;;AAEA;AACA;AACA,YAAG,iBAAErD,UAAF,CAAa/B,UAAUH,SAAvB,CAAH,EAAsC;AACpC,cAAMwF,kBAAkB7C,kBAAkBxC,UAAUH,SAAV,YAAqBmB,oBAArB,IAAmCsB,KAAnC,EAAlB,CAAxB;AACAxB,mBAAS,iBAAEkD,MAAF,CAASqB,eAAT,EAA0BvE,MAA1B,CAAT;AACA,cAAGD,aAAaC,MAAb,CAAH,EAAyB,OAAOA,MAAP;AAC1B;;AAED;AACA;AACA,YAAG,iBAAEqD,OAAF,CAAU7B,MAAM8B,IAAhB,KAAyB,iBAAED,OAAF,CAAU7B,MAAM+B,QAAhB,CAA5B,EAAuD;AACrD,cAAMA,WAAW,iBAAEF,OAAF,CAAU7B,MAAM+B,QAAhB,IAA4B/B,MAAM+B,QAAlC,GAA6C,CAAC/B,MAAM8B,IAAP,CAA9D;AACA,cAAMkB,gBAAgB,iBAAE3B,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACpD;AACA,gBAAMoC,YAAY,wBAAa,iBAAEC,GAAF,CAAMlC,KAAN,UAAmBf,EAAEkD,WAAF,EAAnB,CAAb,CAAlB;AACA,gBAAMc,WAAW,kCAAsBvE,UAAUO,CAAV,CAAtB,CAAjB;AACA,gBAAMiE,UAAU,8BAAmBnB,QAAnB,EAA6BE,SAA7B,EAAwCgB,QAAxC,CAAhB;AACA,mBAAO,CAAChE,CAAD,EAAIiE,OAAJ,CAAP;AACD,WANiC,CAAZ,CAAtB;;AAQA1E,mBAAS,iBAAEkD,MAAF,CAASsB,aAAT,EAAwBxE,MAAxB,CAAT;AACA,cAAGD,aAAaC,MAAb,CAAH,EAAyB,OAAOA,MAAP;AAC1B;;AAED;AACA;AACA;AACA,YAAG,gBAAMoB,QAAN,CAAe0C,KAAf,CAAqBtC,MAAMV,QAA3B,CAAH,EAAyC;AACvC,cAAI6D,eAAe9D,gBAAgBW,MAAMV,QAAtB,EAAgC,KAAK8D,cAAL,CAAoBX,IAApB,CAAyB,IAAzB,CAAhC,EAAgE/D,SAAhE,CAAnB;;AAEA,cAAM2E,cAAe,iBAAEhC,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACnD,gBAAMqD,UAAU,0BAAe,iBAAEvD,OAAF,CAAU,iBAAEE,GAAF,CAAMsD,YAAN,EAAoBlE,CAApB,CAAV,CAAf,EAAkD,kCAAsBP,UAAUO,CAAV,CAAtB,CAAlD,CAAhB;AACA,mBAAO,CAACA,CAAD,EAAIiE,OAAJ,CAAP;AACD,WAHgC,CAAZ,CAArB;;AAKA1E,mBAAS,iBAAEkD,MAAF,CAAS2B,WAAT,EAAsB7E,MAAtB,CAAT;AACA,iBAAOA,MAAP;AACD;AACF;AA5HH;AAAA;AAAA,yCA8HqBwB,KA9HrB,EA8H4BtC,SA9H5B,EA8HuCgB,SA9HvC,EA8HkDF,MA9HlD,EA8H0DJ,KA9H1D,EA8HiE;AAC7D;AACA,YAAG,iBAAEqB,UAAF,CAAa/B,UAAU4F,aAAvB,CAAH,EAA0C;AACxC,iBAAOpD,kBAAkBxC,UAAU4F,aAAV,YAAyB5E,oBAAzB,EAAoCF,cAApC,EAA4CJ,YAA5C,IAAsD4B,KAAtD,EAAlB,CAAP;AACD;;AAED,YAAG,gBAAMJ,QAAN,CAAe0C,KAAf,CAAqBtC,MAAMV,QAA3B,CAAH,EAAyC;AACvC,cAAIiE,mBACFlE,gBAAgBW,MAAMV,QAAtB,EAAgC,KAAKkE,kBAAL,CAAwBf,IAAxB,CAA6B,IAA7B,CAAhC,EAAoE/D,SAApE,EAA+EF,MAA/E,EAAuFJ,KAAvF,CADF;;AAGA,cAAMqF,aAAa,iBAAEpC,SAAF,CAAY,CAAC,GAAD,EAAM,GAAN,EAAWxB,GAAX,CAAe,aAAK;AACjD,gBAAM6D,oBAAoB,iBAAE/D,OAAF,CAAU4D,iBAAiB1D,GAAjB,CAAqB;AAAA,qBAAK,iBAAEqC,GAAF,CAAM5B,CAAN,EAASrB,CAAT,CAAL;AAAA,aAArB,CAAV,CAA1B;AACA,gBAAM0E,cAAcD,kBAAkBb,MAAlB,GAClB,0BAAea,iBAAf,EAAkC,kCAAsBhF,UAAUO,CAAV,CAAtB,CAAlC,CADkB,GACuD2C,SAD3E;AAEA,mBAAO,CAAC3C,CAAD,EAAI0E,WAAJ,CAAP;AACD,WAL8B,CAAZ,CAAnB;AAMA,iBAAOzD,kBAAkBuD,UAAlB,CAAP;AACD;AACF;AAhJH;AAAA;AAAA,qCAkJiBzD,KAlJjB,EAkJwB,CAErB;AApJH;AAAA;AAAA,sCAqJkBA,KArJlB,EAqJyBtC,SArJzB,EAqJoCgB,SArJpC,EAqJ+CF,MArJ/C,EAqJuDJ,KArJvD,EAqJ6D;AACzD,YAAMwF,eAAe5D,MAAMb,OAAN,IAAiB,EAAtC;;AAEA;AACA,YAAGD,cAAc0E,YAAd,CAAH,EAAgC,OAAOA,YAAP;;AAEhC,YAAIzE,UAAUe,kBAAkB0D,YAAlB,CAAd;;AAEA,YAAG,iBAAEnE,UAAF,CAAa/B,UAAUmG,UAAvB,CAAH,EAAuC;AACrC,cAAMC,mBAAmB5D,kBAAkBxC,UAAUmG,UAAV,YAAsBnF,oBAAtB,EAAiCF,cAAjC,EAAyCJ,YAAzC,IAAmD4B,KAAnD,EAAlB,CAAzB;AACAb,oBAAU,iBAAEuC,MAAF,CAASoC,gBAAT,EAA2B3E,OAA3B,CAAV;AACA,cAAGD,cAAcC,OAAd,CAAH,EAA2B,OAAOA,OAAP;AAC5B;;AAED;AACA;AACA;AACA,YAAG,gBAAMS,QAAN,CAAe0C,KAAf,CAAqBtC,MAAMV,QAA3B,CAAH,EAAyC;AACvC,cAAIyE,gBAAgB1E,gBAAgBW,MAAMV,QAAtB,EAAgC,KAAK0E,eAAL,CAAqBvB,IAArB,CAA0B,IAA1B,CAAhC,EAAiE/D,SAAjE,EAA4EF,MAA5E,EAAoFJ,KAApF,CAApB;;AAEA,cAAM6F,eAAe,gCAAqBF,aAArB,CAArB;;AAEA5E,oBAAU,iBAAEuC,MAAF,CAASuC,YAAT,EAAuB9E,OAAvB,CAAV;AACD;AACD,eAAOA,OAAP;AAED;AA/KH;AAAA;AAAA,qCAgLiBa,KAhLjB,EAgLwBtC,SAhLxB,EAgLmCgB,SAhLnC,EAgL8CF,MAhL9C,EAgLsDJ,KAhLtD,EAgL6D;AACzD,YAAM8F,cAAclE,MAAMnB,MAAN,IAAgB,EAApC;;AAEA;AACA,YAAGD,cAAcsF,WAAd,CAAH,EAA+B,OAAOA,WAAP;;AAE/B;AACA,YAAIrF,SAASqB,kBAAkBgE,WAAlB,CAAb;;AAEA;AACA;AACA,YAAG,iBAAEzE,UAAF,CAAa/B,UAAUyG,SAAvB,CAAH,EAAsC;AACpC,cAAMC,kBAAkBlE,kBAAkBxC,UAAUyG,SAAV,YAAqBzF,oBAArB,EAAgCF,cAAhC,EAAwCJ,YAAxC,IAAkD4B,KAAlD,EAAlB,CAAxB;AACAnB,mBAAS,iBAAE6C,MAAF,CAAS0C,eAAT,EAA0BvF,MAA1B,CAAT;AACA,cAAGD,cAAcC,MAAd,CAAH,EAA0B,OAAOA,MAAP;AAC3B;;AAED;AACA;AACA;AACA,YAAG,gBAAMe,QAAN,CAAe0C,KAAf,CAAqBtC,MAAMV,QAA3B,CAAH,EAAyC;AACvC,cAAI+E,eAAehF,gBAAgBW,MAAMV,QAAtB,EAAgC,KAAKgF,cAAL,CAAoB7B,IAApB,CAAyB,IAAzB,CAAhC,EAAgE/D,SAAhE,EAA2EF,MAA3E,EAAmFJ,KAAnF,CAAnB;;AAEA;AACA,cAAMmG,cAAc,gCAAqBF,YAArB,CAApB;;AAEAxF,mBAAS,iBAAE6C,MAAF,CAAS6C,WAAT,EAAsB1F,MAAtB,CAAT;AACD;AACD,eAAOA,MAAP;AACD;AA7MH;AAAA;AAAA,+BAuPW;AAAA,YACAmB,KADA,GACS,IADT,CACAA,KADA;AAAA,YAEAU,KAFA,GAE8BV,KAF9B,CAEAU,KAFA;AAAA,YAEOC,MAFP,GAE8BX,KAF9B,CAEOW,MAFP;AAAA,YAEeC,WAFf,GAE8BZ,KAF9B,CAEeY,WAFf;;AAGP,YAAM4D,iBAAiB,KAAKxE,KAAL,CAAW5B,KAAX,IAAoB,EAA3C;;AAEA;AACA;AACA,YAAGD,YAAYqG,cAAZ,CAAH,EACE,OAAO,8BAAC,iBAAD,EAAuB,KAAKxE,KAA5B,CAAP;;AAEF;AACA;AACA,YAAMtB,YAAY,KAAK8D,iBAAL,CAAuBxC,KAAvB,EAA8BQ,iBAA9B,CAAlB;AACA,YAAMhC,SAAS,KAAK4E,cAAL,CAAoBpD,KAApB,EAA2BQ,iBAA3B,EAA8C9B,SAA9C,CAAf;AACA,YAAG,iBAAEX,QAAF,CAAW6C,WAAX,CAAH,EAA4B;AAC1B,WAAC,GAAD,EAAM,GAAN,EAAW6D,OAAX,CAAmB,aAAK;AACtB,gBAAG7D,YAAY3B,CAAZ,CAAH,EAAmBT,OAAOS,CAAP,IAAYT,OAAOS,CAAP,EAAUyF,KAAV,GAAkBC,OAAlB,EAAZ;AACpB,WAFD;AAGD;;AAED,YAAIC,eAAe,EAAClE,YAAD,EAAQC,cAAR,EAAgBjC,oBAAhB,EAA2BF,cAA3B,EAAmCK,QAAQmB,MAAMnB,MAAjD,EAAyDT,OAAO4B,MAAM5B,KAAtE,EAA6EyG,SAAS7E,MAAM6E,OAA5F,EAAqG1F,SAASa,MAAMb,OAApH,EAAnB;AACA;AACA;AACA,YAAI2F,YAAY,KAAKrE,WAAL,CAAiBmE,YAAjB,CAAhB;;AAEA;AACA;AACA;AACA,YAAMnB,aAAa,KAAKD,kBAAL,CAAwBxD,KAAxB,EAA+BQ,iBAA/B,EAAkD9B,SAAlD,EAA6DF,MAA7D,EAAqEsG,SAArE,CAAnB;AACA,YAAG,iBAAE/G,QAAF,CAAW0F,UAAX,CAAH,EAA2B;AACzB,WAAC,GAAD,EAAM,GAAN,EAAWgB,OAAX,CAAmB,aAAK;AACtB,gBAAMxB,WAAW,kCAAsBvE,UAAUO,CAAV,CAAtB,CAAjB;AACA,gBAAG,yBAAcwE,WAAWxE,CAAX,CAAd,EAA6BgE,QAA7B,CAAH,EACEzE,OAAOS,CAAP,IAAY,0BAAe,CAACT,OAAOS,CAAP,CAAD,EAAYwE,WAAWxE,CAAX,CAAZ,CAAf,EAA2CgE,QAA3C,CAAZ;AACH,WAJD;AAKD;AACD;AACA6B,oBAAY,KAAKrE,WAAL,CAAiBmE,YAAjB,CAAZ;;AAEA;AACA,YAAM/F,SAAS,iBAAEkG,QAAF,CACb,KAAKT,cAAL,CAAoBtE,KAApB,EAA2BQ,iBAA3B,EAA8C9B,SAA9C,EAAyDF,MAAzD,EAAiEsG,SAAjE,CADa,EAEb,EAAC1D,KAAK,CAAN,EAAS4D,QAAQ,CAAjB,EAAoB7D,MAAM,CAA1B,EAA6B8D,OAAO,CAApC,EAFa,CAAf;;AAKA,YAAM9F,UAAU,iBAAE4F,QAAF,CACd,KAAKf,eAAL,CAAqBhE,KAArB,EAA4BQ,iBAA5B,EAA+C9B,SAA/C,EAA0DF,MAA1D,EAAkEsG,SAAlE,CADc,EAEd,EAAC1D,KAAK,CAAN,EAAS4D,QAAQ,CAAjB,EAAoB7D,MAAM,CAA1B,EAA6B8D,OAAO,CAApC,EAFc,CAAhB;;AAKA;AACAL,oCAAmBA,YAAnB,IAAiC/F,cAAjC,EAAyCM,gBAAzC;AACA,YAAMf,QAAQ,KAAKqC,WAAL,CAAiBmE,YAAjB,CAAd;;AAEA,YAAMM,cAAc,iBAAExD,MAAF,CAAS,EAAT,EAAa,KAAK1B,KAAlB,EAAyB,EAAC5B,YAAD,EAAQM,oBAAR,EAAmBG,cAAnB,EAA2BL,cAA3B,EAAmCW,gBAAnC,EAAzB,CAApB;AACA,eAAO,8BAAC,iBAAD,EAAuB+F,WAAvB,CAAP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;AAxTH;;AAAA;AAAA,IAAqB,gBAAMxH,SAA3B,UACSyH,YADT,GACwB,iBAAEJ,QAAF,CAAWvE,kBAAkB2E,YAA7B,EAA2C;AAC/DvE,iBAAa,EAACvC,GAAG,KAAJ,EAAWC,GAAG,KAAd;AADkD,GAA3C,CADxB,SAMSkD,YANT,GAMwBhB,kBAAkBgB,YAN1C,SAOSqC,UAPT,GAOsBrD,kBAAkBqD,UAPxC,SAQStG,SART,GAQqBiD,kBAAkBjD,SARvC,SASS4G,SATT,GASqB3D,kBAAkB2D,SATvC;AA0TD","file":"resolveXYScales.js","sourcesContent":["import _ from 'lodash';\nimport {scalePoint} from 'd3';\nimport React from 'react';\nimport invariant from 'invariant';\n\nimport {\n  makeAccessor,\n  domainFromDatasets,\n  domainFromData,\n  inferDatasetsType,\n  datasetsFromPropsOrDescendants,\n  combineDomains,\n  combineBorderObjects,\n  isValidDomain\n} from './Data';\n\nimport {\n  scaleTypeFromDataType,\n  dataTypeFromScaleType,\n  inferDataTypeFromDomain,\n  initScale,\n  isValidScale\n} from './Scale';\n\nimport {innerRangeX, innerRangeY, innerWidth, innerHeight} from './Margin';\n\n/**\n * `resolveXYScales` is a higher-order-component.\n *\n * @param {Component} Component - The React Component (class) which should be wrapped by this HOC\n * @returns {Component} - A Component which auto-resolves XY scales from given props\n*/\n\nconst errs = {\n  getDomain: (C) =>\n    `Components enhanced by resolveXYScales must have a static getDomain method, ${componentName(C)} does not have one`\n};\nfunction componentName(Component) {\n  return Component.displayName || \"Component wrapped by resolveXYScales\";\n}\nfunction hasScaleFor(scalesObj, key) {\n  return _.isObject(scalesObj) && isValidScale(scalesObj[key]);\n}\nfunction hasPaddingFor(paddingObj, key) {\n  return _.isObject(paddingObj) && _.isNumber(paddingObj[key]);\n}\nfunction hasXYScales(scale) {\n  return _.isObject(scale) && isValidScale(scale.x) && isValidScale(scale.y);\n}\nfunction hasXYDomains(domain) {\n  return _.isObject(domain) && isValidDomain(domain.x) && isValidDomain(domain.y);\n}\nfunction hasXYScaleTypes(scaleType) {\n  return _.isObject(scaleType) && _.isString(scaleType.x) && _.isString(scaleType.y);\n}\nfunction hasAllMargins(margin) {\n  const marginKeys = ['top', 'bottom', 'left', 'right'];\n  return _.isObject(margin) && _.every(marginKeys, k => _.has(margin, k));\n}\nfunction hasAllSpacing(spacing) {\n  const spacingKeys = ['top', 'bottom', 'left', 'right'];\n  return _.isObject(spacing) && _.every(spacingKeys, k => _.has(spacing, k));\n}\n\nfunction mapOverChildren(children, iteratee, ...iterateeArgs) {\n  // loop over all children (react elements) and call iteratee (a function) on each one\n  // iteratee is called with parameters (child.props, child.type, ...iterateeArgs)\n  if(!_.isFunction(iteratee)) throw new Error('mapOverChildren iteratee must be a function');\n\n  return _.compact(React.Children.map(children, child => {\n    if(!child || !React.isValidElement(child)) return null;\n    return iteratee(child.props, child.type, ...iterateeArgs);\n  }));\n}\nfunction omitNullUndefined(obj) {\n  return _.omitBy(obj, v => _.isUndefined(v) || _.isNull(v));\n}\n\n// not currently being used but potentially has some learnings\n// function resolveXYPropsOnComponentOrChildren(propKeys, props, reducers = {}, validators = {}, result = {}) {\n//   const isDone = (o) => (_.every(propKeys, k => _.isObject(o[k]) && _.every(['x', 'y'], xy => _.has(o[k][xy]))));\n//   result = _.pick({...props, ...result}, propKeys);\n\n//   let resolved = {};\n//   _.forEach(propKeys, propKey => {\n//     _.forEach(['x', 'y'], k => {\n//       const isValid = validators[propKey] || (() => true);\n//       if(_.isObject(props[propKey]) && _.has(props[propKey], k) && isValid(props[propKey][k])) {\n//         if(!_.has(result, propKey)) result[propKey] = {};\n//         result[propKey][k] = props[propKey][k];\n//       }\n//     });\n//   });\n\n//   if(isDone(result)) return result;\n\n//   if(React.Children.count(props.children)) {\n//     let childProps = mapOverChildren(props.children, resolveXYPropsOnComponentOrChildren, propKeys, 'props', result);\n//     React.Children.forEach(props.children, child => {\n//       if(!child) return;\n//       childProps.push(resolveXYPropsOnComponentOrChildren(propKeys, child.props, result));\n//     });\n//       let childDomains = [];\n//       React.Children.forEach(props.children, child => {\n//         childDomains = childDomains.concat(this._resolveDomain(child.props, child.type, scaleType));\n//       });\n\n//       console.log('combining domains', childDomains);\n//       const childDomain =  _.fromPairs(['x', 'y'].map(k => {\n//         console.log(_.compact(_.map(childDomains, k)), scaleType[k]);\n//         const kDomain = combineDomains(_.compact(_.map(childDomains, k)), dataTypeFromScaleType(scaleType[k]));\n//         console.log(kDomain);\n//         return [k, kDomain];\n//       }));\n//       console.log('combined domains', childDomain);\n\n//       domain = _.assign(childDomain, domain);\n//       return domain;\n//   }\n\n//   propKeys.forEach(k => {\n//     result[propKeys] = props\n//   })\n// }\n\n\n\nexport default function resolveXYScales(ComposedComponent) {\n  return class extends React.Component {\n    static defaultProps = _.defaults(ComposedComponent.defaultProps, {\n      invertScale: {x: false, y: false},\n    });\n\n    // todo better way for HOC's to pass statics through?\n    static getScaleType = ComposedComponent.getScaleType; \n    static getSpacing = ComposedComponent.getSpacing;\n    static getDomain = ComposedComponent.getDomain;\n    static getMargin = ComposedComponent.getMargin;\n\n    _resolveScaleType(props, Component) {\n      const propsScaleType = props.scaleType || {};\n\n      // short-circuit if all scale types provided\n      if(hasXYScaleTypes(propsScaleType)) return propsScaleType;\n\n      // start with any scale types in props, try to resolve the rest\n      let scaleType = omitNullUndefined(propsScaleType);\n\n      // if Component provides a custom static getScaleType method\n      // use it to determine remaining scale types\n      if(_.isFunction(Component.getScaleType)) {\n        const componentScaleType = omitNullUndefined(Component.getScaleType(props));\n        scaleType = _.assign(componentScaleType, scaleType);\n        if(hasXYScaleTypes(scaleType)) return scaleType;\n      }\n\n      // todo infer scaleType from domain?\n      // if component has domain props,\n      // infer the data type, & use that to get scale type\n      if(_.isObject(props.domain) && (isValidDomain(props.domain.x) || isValidDomain(props.domain.y))) {\n        // console.log('inferring scale type from domain');\n        const domainScaleType = _.fromPairs(['x', 'y'].map(k => {\n          const domain = props.domain[k];\n          return isValidDomain(domain) ?\n            [k, scaleTypeFromDataType(inferDataTypeFromDomain(domain))] :\n            [k, undefined];\n        }));\n        scaleType = _.assign(domainScaleType, scaleType);\n        if(hasXYScaleTypes(scaleType)) return scaleType;\n      }\n\n      // if Component has data or datasets props,\n      // infer the data type, & use that to get scale type\n      if(_.isArray(props.data) || _.isArray(props.datasets)) {\n        const datasets = _.isArray(props.datasets) ? props.datasets : [props.data];\n        const datasetScaleType = _.fromPairs(['x', 'y'].map(k => {\n          // const kAccessor = makeAccessor(_.get(props, `getValue.${k}`));\n          const kAccessor = makeAccessor(_.get(props, `get${k.toUpperCase()}`));\n          const kDataType = inferDatasetsType(datasets, kAccessor);\n          const kScaleType = scaleTypeFromDataType(kDataType);\n          return [k, kScaleType];\n        }));\n\n        scaleType = _.assign(datasetScaleType, scaleType);\n        return scaleType;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their scale types the same way\n      if(React.Children.count(props.children)) {\n        // console.log('get scaletype from children')\n        let childScaleTypes = mapOverChildren(props.children, this._resolveScaleType.bind(this));\n\n        const childScaleType =  _.fromPairs(['x', 'y'].map(k => {\n          // todo warn on multiple scale types, probably not what you want\n          const kScaleTypes = _.compact(_.uniq(_.map(childScaleTypes, k)));\n          const kScaleType = (kScaleTypes.length === 1) ? kScaleTypes[0] : \"ordinal\";\n          return [k, kScaleType];\n        }));\n\n        scaleType = _.assign(childScaleType, scaleType);\n        return scaleType;\n      }\n    }\n\n    _resolveDomain(props, Component, scaleType) {\n      const propsDomain = props.domain || {};\n\n      // short-circuit if all domains provided\n      if(hasXYDomains(propsDomain)) return {x: propsDomain.x, y: propsDomain.y};\n\n      // start with any domains in props, and try to resolve the rest\n      let domain = omitNullUndefined(propsDomain);\n\n      // if Component provides a custom static getDomain method\n      // use it to determine remaining domains\n      if(_.isFunction(Component.getDomain)) {\n        const componentDomain = omitNullUndefined(Component.getDomain({scaleType, ...props}));\n        domain = _.assign(componentDomain, domain);\n        if(hasXYDomains(domain)) return domain;\n      }\n\n      // if Component has data or datasets props,\n      // use the default domainFromDatasets function to determine a domain from them\n      if(_.isArray(props.data) || _.isArray(props.datasets)) {\n        const datasets = _.isArray(props.datasets) ? props.datasets : [props.data];\n        const datasetDomain = _.fromPairs(['x', 'y'].map(k => {\n          // const kAccessor = makeAccessor(_.get(props, `getValue.${k}`));\n          const kAccessor = makeAccessor(_.get(props, `get${k.toUpperCase()}`));\n          const dataType = dataTypeFromScaleType(scaleType[k]);\n          const kDomain = domainFromDatasets(datasets, kAccessor, dataType);\n          return [k, kDomain];\n        }));\n\n        domain = _.assign(datasetDomain, domain);\n        if(hasXYDomains(domain)) return domain;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their domains the same way,\n      // and combine them into a single domain, if there are multiple\n      if(React.Children.count(props.children)) {\n        let childDomains = mapOverChildren(props.children, this._resolveDomain.bind(this), scaleType);\n\n        const childDomain =  _.fromPairs(['x', 'y'].map(k => {\n          const kDomain = combineDomains(_.compact(_.map(childDomains, k)), dataTypeFromScaleType(scaleType[k]));\n          return [k, kDomain];\n        }));\n\n        domain = _.assign(childDomain, domain);\n        return domain;\n      }\n    }\n\n    _resolveTickDomain(props, Component, scaleType, domain, scale) {\n      // todo resolve directly from ticks/tickCount props?\n      if(_.isFunction(Component.getTickDomain)) {\n        return omitNullUndefined(Component.getTickDomain({scaleType, domain, scale, ...props}));\n      }\n\n      if(React.Children.count(props.children)) {\n        let childTickDomains =\n          mapOverChildren(props.children, this._resolveTickDomain.bind(this), scaleType, domain, scale);\n\n        const tickDomain = _.fromPairs(['x', 'y'].map(k => {\n          const kChildTickDomains = _.compact(childTickDomains.map(v => _.get(v, k)));\n          const kTickDomain = kChildTickDomains.length ?\n            combineDomains(kChildTickDomains, dataTypeFromScaleType(scaleType[k])) : undefined;\n          return [k, kTickDomain];\n        }));\n        return omitNullUndefined(tickDomain);\n      }\n    }\n\n    _resolveLabels(props) {\n\n    }\n    _resolveSpacing(props, Component, scaleType, domain, scale){\n      const propsSpacing = props.spacing || {};\n\n      // short-circuit if all spacings provided\n      if(hasAllSpacing(propsSpacing)) return propsSpacing;     \n\n      let spacing = omitNullUndefined(propsSpacing);\n\n      if(_.isFunction(Component.getSpacing)) {\n        const componentSpacing = omitNullUndefined(Component.getSpacing({scaleType, domain, scale, ...props}));\n        spacing = _.assign(componentSpacing, spacing);\n        if(hasAllSpacing(spacing)) return spacing;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their spacings the same way,\n      // and combine them into a single spacing, if there are multiple\n      if(React.Children.count(props.children)) {\n        let childSpacings = mapOverChildren(props.children, this._resolveSpacing.bind(this), scaleType, domain, scale);\n\n        const childSpacing = combineBorderObjects(childSpacings);\n\n        spacing = _.assign(childSpacing, spacing);\n      }\n      return spacing;\n\n    }\n    _resolveMargin(props, Component, scaleType, domain, scale) {\n      const propsMargin = props.margin || {};\n\n      // short-circuit if all margins provided\n      if(hasAllMargins(propsMargin)) return propsMargin;\n\n      // start with any margins in props, and try to resolve the rest\n      let margin = omitNullUndefined(propsMargin);\n\n      // if Component provides a custom static getMargin method\n      // use it to determine remaining domains\n      if(_.isFunction(Component.getMargin)) {\n        const componentMargin = omitNullUndefined(Component.getMargin({scaleType, domain, scale, ...props}));\n        margin = _.assign(componentMargin, margin);\n        if(hasAllMargins(margin)) return margin;\n      }\n\n      // if Component has children,\n      // recurse through descendants to resolve their margins the same way,\n      // and combine them into a single margin, if there are multiple\n      if(React.Children.count(props.children)) {\n        let childMargins = mapOverChildren(props.children, this._resolveMargin.bind(this), scaleType, domain, scale);\n\n        // console.log('combining child margins', childMargins);\n        const childMargin = combineBorderObjects(childMargins);\n\n        margin = _.assign(childMargin, margin);\n      }\n      return margin;\n    }\n\n    _makeScales = ({width, height, scaleType={}, domain={}, margin={}, scale={}, spacing={}}) => {\n      const {invertScale, nice, tickCount, ticks} = this.props;\n      \n      const innerChartWidth = innerWidth(width, margin);\n      const innerChartHeight = innerHeight(height, margin);\n\n      const range = {\n        x: innerRangeX(innerChartWidth, spacing).map(v => v - (spacing.left || 0)),\n        y: innerRangeY(innerChartHeight, spacing).map(v => v - (spacing.top || 0))\n      };\n      //innerRange functions produce range (i.e. [5,20]) and map function normalizes to 0 (i.e. [0,15])\n\n      return _.fromPairs(['x', 'y'].map(k => {\n        // use existing scales if provided, otherwise create new\n        if(hasScaleFor(scale, k)) return [k, scale[k]];\n\n        // create scale from domain/range\n        const kScale = initScale(scaleType[k]).domain(domain[k]).range(range[k]);\n\n        // todo - ticks, nice and getDomain should be an axis prop instead, and axis should have getDomain\n\n        // set `nice` option to round scale domains to nicer numbers\n        // const kTickCount = tickCount ? tickCount[k] : 10;\n        // if(nice && nice[k] && _.isFunction(kScale.nice)) kScale.nice(kTickCount);\n\n        // extend scale domain to include custom `ticks` if passed\n        //\n        // if(ticks[k]) {\n        //   const dataType = dataTypeFromScaleType(scaleType[k]);\n        //   const tickDomain = domainFromData(ticks[k], _.identity, dataType);\n        //   kScale.domain(combineDomains([kScale.domain(), tickDomain]), dataType);\n        // }\n\n        // reverse scale domain if `invertScale` is passed\n        // if(invertScale[k]) kScale.domain(kScale.domain().reverse());\n\n        return [k, kScale];\n      }));\n    };\n\n    render() {\n      const {props} = this;\n      const {width, height, invertScale} = props;\n      const scaleFromProps = this.props.scale || {};\n\n      // short-circuit if scales provided\n      // todo warn/throw if bad scales are passed\n      if(hasXYScales(scaleFromProps))\n        return <ComposedComponent {...this.props} />;\n\n      // scales not provided, so we have to resolve them\n      // first resolve scale types and domains\n      const scaleType = this._resolveScaleType(props, ComposedComponent);\n      const domain = this._resolveDomain(props, ComposedComponent, scaleType);\n      if(_.isObject(invertScale)) {\n        ['x', 'y'].forEach(k => {\n          if(invertScale[k]) domain[k] = domain[k].slice().reverse();\n        })\n      }\n\n      let scaleOptions = {width, height, scaleType, domain, margin: props.margin, scale: props.scale, padding: props.padding, spacing: props.spacing};\n      // create a temporary scale with size & domain, which may be used by the Component to calculate margin/tickDomain\n      // (eg. to create and measure labels for the scales)\n      let tempScale = this._makeScales(scaleOptions);\n\n      // getTickDomain gives children the opportunity to modify the domain to include their scale ticks\n      // (can't happen in getDomain, because it can't be done until the base domain/tempScale has been created)\n      //nice-ing happens in the getTickDomain function inside of _resolveTickDomain\n      const tickDomain = this._resolveTickDomain(props, ComposedComponent, scaleType, domain, tempScale);\n      if(_.isObject(tickDomain)) {\n        ['x', 'y'].forEach(k => {\n          const dataType = dataTypeFromScaleType(scaleType[k]);\n          if(isValidDomain(tickDomain[k], dataType))\n            domain[k] = combineDomains([domain[k], tickDomain[k]], dataType);\n        })\n      }\n      // update tempScale to use new domain before creating margins\n      tempScale = this._makeScales(scaleOptions);\n\n      // then resolve the margins\n      const margin = _.defaults(\n        this._resolveMargin(props, ComposedComponent, scaleType, domain, tempScale),\n        {top: 0, bottom: 0, left: 0, right: 0}\n      );\n\n      const spacing = _.defaults(\n        this._resolveSpacing(props, ComposedComponent, scaleType, domain, tempScale),\n        {top: 0, bottom: 0, left: 0, right: 0}\n      );\n\n      // create real scales from resolved margins\n      scaleOptions = {...scaleOptions, margin, spacing};\n      const scale = this._makeScales(scaleOptions);\n      \n      const passedProps = _.assign({}, this.props, {scale, scaleType, margin, domain, spacing});\n      return <ComposedComponent {...passedProps} />;\n\n      // todo spacing/padding\n      // todo includeZero\n      // todo purerender/shouldcomponentupdate?\n      // todo resolve margins if scales are present\n      // todo use zero for any margins which can't be resolved\n      // todo throw if cannot resolve scaleType\n      // todo throw if cannot resolve domain\n      // todo check to make sure margins didn't change after scales resolved?\n    }\n  }\n}\n"]}