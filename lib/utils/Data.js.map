{"version":3,"sources":["../../src/utils/Data.js"],"names":["makeAccessor","datasetsFromPropsOrDescendants","inferDataType","inferDatasetsType","isValidDomain","combineDomains","combineBorderObjects","domainFromData","getDataDomainByAxis","domainFromDatasets","domainFromRangeData","combineDatasets","key","isFunction","isNull","isUndefined","identity","property","props","isArray","datasets","data","Children","count","children","forEach","concat","child","accessor","Error","every","d","i","isNumber","isDate","types","map","uniqTypes","uniq","length","domain","type","domains","dataType","undefined","flatten","compact","borderObjects","fromPairs","k","get","maxBy","horizontal","getX","getY","rangeAxis","rangeStartAccessor","rangeEndAccessor","datasetsInfo","combineKey","datasetLookups","datasetInfo","keyBy","allCombineValues","uniqBy","toString","sortBy","value","combinedDatum","combineValue","datasetIndex","dataKeys","Object","keys","datasetLookup","has","datum","newDataKey","originalDataKey"],"mappings":"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","file":"Data.js","sourcesContent":["import _ from 'lodash';\nimport {extent} from 'd3';\nimport React from 'react';\n\n/**\n * `makeAccessor` creates an accessor or \"getter\" function given a variety of options\n * to be used for retrieving a data value from within an object or array\n *\n * If given a function, it is passed through.\n * If given null or undefined, the getter is the identity function - ie. returns whatever it's passed\n * If given an array index or deep object key string, the value will be retrieved using _.property\n *\n * @example\n * makeAccessor(null)(4); // 4\n * makeAccessor(d => d + 1)(4); // 5\n * makeAccessor(1)(['a', 'b', 'c']); // 'b'\n * makeAccessor('x.0.y')({x: [{y: 9}]}); // 9\n *\n * @param {any} key - Getter, which may be a function, integer, string, null, or undefined;\n * @returns {function} accessor - Accessor function\n */\nexport function makeAccessor(key) {\n  return _.isFunction(key) ? key :\n    _.isNull(key) || _.isUndefined(key) ? _.identity :\n    _.property(key);\n}\n\n/**\n * `datasetsFromPropsOrDescendants` expects a `props` object which may have `children`.\n * if `props` has `data` or `datasets`, returns it; otherwise recursively searches props.children\n * for components have `data` or `datasets` and combines them into one `datasets` array.\n * `props.data` is wrapped in array because this returns `datasets` (multiple arrays of `data`)\n *\n * @param {Object} props - A React props object, which may have `children` with their own props.\n * @returns {Array.<Array>} datasets - An array of arrays of data objects\n */\nexport function datasetsFromPropsOrDescendants(props) {\n  if(_.isArray(props.datasets)) {\n    return props.datasets;\n  } else if(_.isArray(props.data)) {\n    return [props.data];\n  } else if(React.Children.count(props.children)) {\n    let datasets = [];\n    // use Children.forEach instead of map, because Children.map flattens the arrays\n    React.Children.forEach(props.children, child => {\n      datasets = datasets.concat(datasetsFromPropsOrDescendants(child.props));\n    });\n    return datasets;\n  }\n  return [];\n}\n\nexport function inferDataType(data, accessor = _.identity) {\n  if(!_.isArray(data))\n    throw new Error('inferDataType expects a data array');\n  else if(_.every(data, (d, i) => _.isUndefined(accessor(d, i))))\n    return 'categorical'; // should this be allowed?\n  else if(_.every(data, (d, i) => _.isNumber(accessor(d, i)) || _.isUndefined(accessor(d, i))))\n    return 'number';\n  else if(_.every(data, (d, i) => _.isDate(accessor(d, i)) || _.isUndefined(accessor(d, i))))\n    return 'time';\n  else\n    return 'categorical';\n}\n\nexport function inferDatasetsType(datasets, accessor = _.identity) {\n  if(!_.isArray(datasets))\n    throw new Error('inferDatasetsType expects a datasets array');\n\n  const types = datasets.map(data => inferDataType(data, accessor));\n  const uniqTypes = _.uniq(types);\n  return (uniqTypes.length === 1) ? uniqTypes[0] : 'categorical';\n}\n\nexport function isValidDomain(domain, type = 'categorical') {\n  return _.isArray(domain) && !!domain.length && (\n      // categorical domain can be any array of anything\n      type === 'categorical' ||\n      // number/time domains should look like [min, max]\n      (type === 'number' && domain.length === 2 && _.every(domain, _.isNumber)) ||\n      (type === 'time' && domain.length === 2 && _.every(domain, _.isDate))\n    );\n}\n\nexport function combineDomains(domains, dataType) {\n  if(!_.isArray(domains)) return undefined;\n  return (dataType === 'categorical') ?\n    _.uniq(_.flatten(_.compact(domains))) :\n    extent(_.flatten(domains));\n}\n\nexport function combineBorderObjects(borderObjects){\n  return _.fromPairs(['top', 'bottom', 'left', 'right'].map(k => {\n    // combine border objects by taking the max value of each spacing direction\n    return [k, _.get(_.maxBy(borderObjects, k), k)];\n  }));\n}\n\nexport function domainFromData(data, accessor = _.identity, type = undefined) {\n  if(!type) type = inferDataType(data, accessor);\n  return (type === 'number' || type === 'time') ?\n    extent(data.map(accessor)) :\n    _.uniq(data.map(accessor));\n}\n\nexport function getDataDomainByAxis(props) {\n  const {horizontal, data, getX, getY} = props;\n  const accessor = horizontal ?  makeAccessor(getY) : makeAccessor(getX);\n  // only have to specify range axis domain, other axis uses default domainFromData\n  const rangeAxis = horizontal ? 'y' : 'x';\n  return {\n    [rangeAxis]: domainFromData(data, accessor)\n  };\n}\n\nexport function domainFromDatasets(datasets, accessor = _.identity, type = undefined) {\n  // returns the default domain of a collection of datasets with an accessor function\n  // for numeric and date-type datasets, returns the extent (min and max) of the numbers/dates\n  // for categorical datasets, returns the set of distinct category values\n  if(!type) type = inferDatasetsType(datasets, accessor);\n  const domains = datasets.map(data => domainFromData(data, accessor, type));\n  return combineDomains(domains, type);\n}\n\nexport function domainFromRangeData(data, rangeStartAccessor, rangeEndAccessor, dataType) {\n  // returns the domain of dataset for which each datum represents a range of values\n  // ie. has a start and end value rather than a single value\n  // for example, time ranges\n\n  if(!dataType) dataType = inferDataType(data, rangeStartAccessor);\n  switch(dataType) {\n    case 'number':\n    case 'time':\n      return extent(_.flatten([\n        extent(data, (d, i) => +rangeStartAccessor(d, i)),\n        extent(data, (d, i) => +rangeEndAccessor(d, i))\n      ]));\n    case 'categorical':\n      return _.uniq(_.flatten([data.map(rangeStartAccessor), data.map(rangeEndAccessor)]));\n  }\n  return [];\n}\n\nexport function combineDatasets(datasetsInfo=[], combineKey='x') {\n  // combineDatasets combines multiple datasets into one, joined on a common key 'combineKey'\n  // datasetsInfo is an array that looks like:\n  // [\n  //   {data: [{x: 0, y: 3}, ...], combineKey: 'x', dataKeys: {y: 'y0'}}\n  //   {data: [{count: 0, value: 4}], combineKey: 'count', dataKeys: {value: 'y1'}}\n  // ]\n  // where `data` is an array of data points of any shape\n  // `combineKey` is the key for the value which the datasets are joined on\n  // `dataKeys` are getters for other values in each datapoint which should be merged into the combined dataset\n  //   - key = getter in original datapoint, value = setter for combined dataset\n  // example above (with default combinedKey) results in:\n  // [{x: 0, y0: 3, y1: 4}, ...]\n\n  // index each dataset by its combineKey values so we can quickly lookup if it has data for a given value\n  const datasetLookups = datasetsInfo.map(datasetInfo => {\n    const {data} = datasetInfo;\n    return _.keyBy(data, datasetInfo.combineKey || combineKey);\n  });\n\n  // create a unique sorted array containing all of the data values for combineKey in all datasets\n  const allCombineValues = _(datasetsInfo)\n    .map(datasetInfo => datasetInfo.data.map(makeAccessor(datasetInfo.combineKey || combineKey)))\n    .flatten()\n    .uniqBy(_.toString) // uniq by string, otherwise dates etc. are not unique\n    .sortBy()\n    .value();\n\n  // for each of the unique combineKey data values, go through each dataset and look for a combineKey value that matches\n  // if we find it, combine the values for that datum's dataKeys into the final combinedDatum object\n  return allCombineValues.map(combineValue => {\n    let combinedDatum = {[combineKey]: combineValue};\n\n    datasetsInfo.forEach((datasetInfo, datasetIndex) => {\n      if(!datasetInfo.dataKeys || !Object.keys(datasetInfo.dataKeys).length) return;\n      const datasetLookup = datasetLookups[datasetIndex];\n      if(!_.has(datasetLookup, combineValue)) return;\n\n      const datum = datasetLookup[combineValue];\n      _.forEach(datasetInfo.dataKeys, (newDataKey, originalDataKey) => {\n        combinedDatum[newDataKey] = datum[originalDataKey];\n      });\n    });\n\n    return combinedDatum;\n  });\n}\n"]}